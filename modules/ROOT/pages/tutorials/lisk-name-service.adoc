= Lisk Name Service (LNS) Tutorial
Mona Bärenfänger <mona@lightcurve.io>
// Settings
:toc: preamble
:toclevels: 3
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
:experimental:
// URLs
:url_wikipedia_dns: https://en.wikipedia.org/wiki/Domain_Name_System
:url_ens: https://docs.ens.domains/

How to create a blockchain application that offers a domain name service for blockchain accounts, similar to {url_wikipedia_dns}[DNS^] and {url_ens}[ENS^].

This service allows an account to register one or multiple `.lsk` domains for a certain amount of time (1-5 years).

If an account registers a domain, it becomes a human readable identifier for the account and can then be used to refer to the account instead of the (less human-readable) Lisk32 account address.

Additionally, it is possible to create TXT and CNAME records for each domain owned by an account.

== LNS application overview
image:tutorials/lns/lns-overview.png[]

:sectnums:
== Dependencies

[options="header",]
|===
|Dependencies |Version
|Git | v2 (latest)
|Node.js | v12 (latest)
|Lisk Commander | v5.1.2 (latest)
|===

=== Node.js

If you are using NVM, install the correct version as shown below:

[source,bash]
----
nvm install v12.22.3
----

=== Lisk Commander

It is recommended to install Lisk Commander globally with NPM to facilitate the convenient usage of the Lisk Commander CLI.

[source,bash]
----
npm install --global lisk-commander
----

To check the successful installation of Lisk Commander, run for example:

[source,bash]
----
$ lisk --version
lisk-commander/5.1.2 darwin-x64 node-v12.22.3
----

== Bootstrapping the default application

Create a dedicated folder `lisk-name-service/`, which will contain the files for the application.

Inside of this folder, execute the `lisk init` command of Lisk Commander as shown below:

[source,bash]
----
mkdir lisk-name-service
cd lisk-name-service
lisk init
----

Next you will be prompted for the application name, description, author and license.

----
Using template "lisk-ts"
Initializing git repository
Updating .liskrc.json file
Creating project structure
? Application name lns
? Application description My blockchain application
? Author yourName
? License ISC
----

This will generate a lot of new files and folders, resulting in the following structure:

----
.
├── README.md
├── bin <1>
├── config <2>
├── jest.config.js
├── package-lock.json
├── package.json
├── src
│   ├── app <3>
│   │   ├── app.ts <4>
│   │   ├── index.ts
│   │   ├── modules <5>
│   │   ├── modules.ts <6>
│   │   ├── plugins <7>
│   │   └── plugins.ts <8>
│   └── commands <9>
├── test <10>
└── tsconfig.json
----

<1> `bin/` contains the `run` script which starts the application CLI.
<2> `config/` contains the default configuration and genesis block for the application.
<3> `app/` contains the files of the blockchain application.
<4> `app.ts` creates the `Application` instance.
<5> `modules/` contains the application modules (currently empty).
<6> `modules.ts` registers the modules with the application.
<7> `plugins/` contains the application plugins (currently empty).
<8> `plugins.ts` registers the plugins with the application.
<9> `commannds/` contains the application CLI commands.
<10> `tests/` contains functional, network and unit tests for the blockchain application.

These files create a ready-to-start blockchain application, configured for a local devnet, which uses only the default modules of the Lisk SDK.

The application is created in the file `app.ts`:

.lisk-name-service/src/app/app.ts
[source,typescript]
----
import { Application, PartialApplicationConfig, utils } from 'lisk-sdk';
import { registerModules } from './modules';
import { registerPlugins } from './plugins';

export const getApplication = (
	genesisBlock: Record<string, unknown>,
	config: PartialApplicationConfig,
): Application => {
	const app = Application.defaultApplication(genesisBlock, config); // <1>

	registerModules(app); // <2>
	registerPlugins(app); // <3>

	return app;
};
----

<1> Creates blockchain application with the default modules.
<2> Will register additionnal modules to the application.
Currently, no additionnal modules are available for the application.
To add new modules update the `modules.ts` file.
<3> Will register additionnal plugins to the application.
Currently, no plugins are available for the application.
To add new plugins update the `plugins.ts` file.

To verify the successful bootstrap of the blockchain application, start it with the following command:

.lisk-name-service/
[source,bash]
----
./bin/run start
----

And observe the displayed log messages in the console.
If on errors are thrown, the application will start to add new locks every 10 seconds after the initial startup.

Once it is verified that the application runs correctly, stop the node again with kbd:[Ctrl] + kbd:[C].

After the application was started for the first time, the corresponding application data can bbe found under the path `~/.lisk/lns/`

.~/.lisk/lns/
----
.
├── config
│   └── default
│       ├── config.json <1>
│       └── genesis_block.json <2>
├── data  <3>
│   ├── blockchain.db
│   ├── forger.db
│   ├── genesis_block_compiled
│   └── node.db
├── logs  <4>
│   ├── lisk.log
│   ├── plugin-LnsDashboard.log
│   ├── plugin-forger.log
│   └── plugin-httpApi.log
├── plugins <5>
│   └── data
└── tmp <6>
    ├── pids
    └── sockets
----

<1> `config.json` is the configuration file of the blockchain application.
<2> `genesis_block.json` is the genesis block of the blockchain application.
<3> `data` contains all on-chain data of the blockchain, stored in key-value stores.
<4> `logs` contains the file logs of the application and its' plugins.
<5> `plugins` contains all off-chain data of the application, stored in key-value-stores.
<6> `tmp` contains temporary application data.

To customize the default blockchain application to suit our desired use case, we will now generate the LNS module skeleton.

Create the module skeleton by executing the command `lisk generate:module` like shown below:

.lisk-name-service/
[source,bash]
----
lisk generate:module lns 1000
----

The command expects two arguments:
 . The module name
 . The module ID

This will information will be used to create the corresponding module skeleton.

----
├── src
│   ├── app
│   │   ├── app.ts
│   │   ├── index.ts
│   │   ├── modules
│   │   │   └── lns.ts
│   │   │       └── lns_module.ts <1>
│   │   ├── modules.ts
│   │   ├── plugins
│   │   └── plugins.ts
----

<1> The newly created skeleton for the LNS module

Read the following sections to learn how to further extend the LNS module to suit the desired use case.

== Creating the LNS module assets

The first part of the module that we implement here are the assets to handle the different transaction types `register`, `reverse lookup` and `update records`.

=== Register Domain

As first step for creating the asset, use Lisk Commander again, this time, to create the asset skeleton.

Execute the following command:

.lisk-name-service/
[source,bash]
----
lisk generate:asset lns register 1
----

----
├── src
│   ├── app
│   │   ├── app.ts
│   │   ├── index.ts
│   │   ├── modules
│   │   │   └── lns.ts
│   │   │       ├── assets
│   │   │       │   └── register.ts <1>
│   │   │       └── lns_module.ts
│   │   ├── modules.ts
│   │   ├── plugins
│   │   └── plugins.ts
----

<1> The newly created skeleton for the `register` asset.

When you open `register.ts` at this point, it will look like this:

.lisk-name-service/src/app/modules/lns/assets/register.ts
[source,typescript]
----
import { BaseAsset, ApplyAssetContext, ValidateAssetContext } from 'lisk-sdk';

export class RegisterAsset extends BaseAsset {
  public name = 'register';
  public id = 1;

  // Define schema for asset
	public schema = {
    $id: 'lns/register-asset',
		title: 'RegisterAsset transaction asset for lns module',
		type: 'object',
		required: [],
		properties: {},
  };

  public validate({ asset }: ValidateAssetContext<{}>): void {
    // Validate your asset
  }

	// eslint-disable-next-line @typescript-eslint/require-await
  public async apply({ asset, transaction, stateStore }: ApplyAssetContext<{}>): Promise<void> {
		throw new Error('Asset "register" apply hook is not implemented.');
	}
}
----

As you can see, the asset name and ID are already prefilled with the values we provided when creatinng the asset skeleton.

As next step, we want to define the asset schema, which defines which kind of data is expected by the application to successfully register a new domain for a user account.

==== Schema

Create a new folder `data/` inside the `lns` module folder.

.lisk-name-service/src/app/modules/lns/
[source,bash]
----
mkdir data
----

This folder is created to maintain a better overview, and will store all account and asset schemas which are relevant to the LNS module.

.lisk-name-service/src/app/modules/lns/
[source,bash]
----
mkdir data/assets
----

Inside the `data/assets` folder, create a new file `register.ts`, which will contain the schemas related to the `register` asset.

The first thing we define in the file, is an interface  for the expected asset data of a `register` transaction.
It describes in a straight-forward way, what data is expected to be in the transaction asset for a successful registration of a new domain.

The following information is required for a successful registration:

* `name`(string): The domain name to register for the sending account.
* `ttl`(number): Time-To-Live: Time which needs to pass, until the records for the domain can be updated again.
* `registerFor`(number): The duration to reserve this domain for the sender account.

The corresponding interface looks like this:

.src/app/modules/lns/data/assets/register.ts
[source,typescript]
----
export interface RegisterAssetProps {
	name: string;
	ttl: number;
	registerFor: number;
}
----

This is described in the following asset schema, which is shown below:

.src/app/modules/lns/data/assets/register.ts
[source,typescript]
----
export const registerAssetPropsSchema = {
  $id: 'lns/assets/register',
  title: 'RegisterAsset transaction asset for lns module',
  type: 'object',
  required: ['name', 'ttl', 'registerFor'],
  properties: {
    name: {
      dataType: 'string',
      fieldNumber: 1,
    },
    ttl: {
      dataType: 'uint32',
      fieldNumber: 2,
    },
    registerFor: {
      dataType: 'uint32',
      fieldNumber: 3,
    },
  },
}
----

Add the interface and asset schema to the file and save it.

Now,  just include the schema in the asset file:

.lisk-name-service/src/app/modules/lns/assets/register.ts
[source,typescript]
----
import { BaseAsset, ApplyAssetContext, ValidateAssetContext } from 'lisk-sdk';
import { RegisterAssetProps, registerAssetPropsSchema } from '../data';

export class RegisterAsset extends BaseAsset<RegisterAssetProps> {
  public name = 'register';
  public id = 1;

  // Define schema for asset
  public schema = registerAssetPropsSchema;

  // ...
}
----

==== Validation

Create a new file `constants.ts` inside the `lns` module folder.

This file is created to maintain a better overview, and will store all constants which are relevant to the LNS module and its' assets.

Add the following two constants.

.src/app/modules/lns/constants.ts
[source,typescript]
----
export const MIN_TTL_VALUE = 60 * 60; // 1 hour
export const VALID_TLDS = ['lsk'];
----

Now import the constants into the `register` asset, and use them to check the validity of transaction assets:

We want to validate the following:

. The TTL value needs to be above the minimum defined TTL value (60 * 60).
. The `registerFor` value needs to be between 1 and 5.
. Only second level domain names can bbe registered.
. Only domains with valid TLDs can be registered.

The corresponding checks look like this:

.lisk-name-service/src/app/modules/lns/assets/register.ts
[source,typescript]
----
import { BaseAsset, ApplyAssetContext, ValidateAssetContext } from 'lisk-sdk';
import { RegisterAssetProps, registerAssetPropsSchema } from '../data';
import { MIN_TTL_VALUE, VALID_TLDS } from '../constants';

export class RegisterAsset extends BaseAsset<RegisterAssetProps> {

    // ...

  public validate({ asset }: ValidateAssetContext<RegisterAssetProps>): void {
		if (asset.ttl < MIN_TTL_VALUE) {
			throw new Error(`Must set TTL value larger or equal to ${MIN_TTL_VALUE}`);
		}

		if (asset.registerFor < 1) {
			throw new Error('You can register name at least for 1 year.');
		}

		if (asset.registerFor > 5) {
			throw new Error('You can register name maximum for 5 year.');
		}

		const chunks = asset.name.split(/\./);

		if (chunks.length > 2) {
			throw new Error('You can only register second level domain name.');
		}

		if (!VALID_TLDS.includes(chunks[1])) {
			throw new Error(`Invalid TLD found "${chunks[1]}". Valid TLDs are "${VALID_TLDS.join()}"`);
		}
	}

    // ...
}
----

==== State change

If the validation of the transaction asset doesn't throw any errors, the `apply()` function is executed, which allows state changes on the blockchain, based on the received transaction data.

The following logic is implemented in the `apply()` function:

* Checks, if the domain name was already registered, and throws an error in this case.
* Creates a new LNS object based on the asset data of the received transaction and saves it in the blockchain.
* Adds the namehash output of the domain name to the sender account under the key `lns.ownNodes`.

.src/app/modules/lns/assets/register.ts
[source,typescript]
----
import { addYears } from 'date-fns';
import { BaseAsset, ApplyAssetContext, ValidateAssetContext } from 'lisk-sdk';
import { LNSAccountProps, RegisterAssetProps, registerAssetPropsSchema } from '../data';
import { createLNSObject, getLNSObject, getNodeForName } from '../storage';
import { MIN_TTL_VALUE, VALID_TLDS } from '../constants';

export class RegisterAsset extends BaseAsset<RegisterAssetProps> {

    // ...

    public async apply({
            asset,
            stateStore,
            transaction,
        }: ApplyAssetContext<RegisterAssetProps>): Promise<void> {
            // Get namehash output of the domain anme
            const node = getNodeForName(asset.name);

            // Check if this domain is already registered on the blockchain
            const existingDomain = await getLNSObject(stateStore, node);
            if (existingDomain) {
                throw new Error(`The name "${asset.name}" already registered`);
            }

            // Create the LNS object and save it on the blockchain
            const lnsObject = {
                name: asset.name,
                ttl: asset.ttl,
                expiry: Math.ceil(addYears(new Date(), asset.registerFor).getTime() / 1000),
                ownerAddress: transaction.senderAddress,
                records: [],
            };
            await createLNSObject(stateStore, lnsObject);

            // Get the sender account
            const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);

            // Add the namehash output of the domain to the sender account
            sender.lns.ownNodes = [...sender.lns.ownNodes, node];

            // Save the updated sender account on the blockchain
            await stateStore.account.set(sender.address, sender);
        }
    }

    // ...
}
----

Several utility functions are used inside of the apply function, which are implemented in a new file under the path `src/app/modules/lns/storage.ts`.
The implementation of these functions is explained in the next question in detail.

==== Utility functions

Create a new file `storage.ts` in the LNS module folder.

Implement the following interfaces and schemas:

* Interface and schema for an LNS node.
* Interface and schema for an LNS node record.

Implement the following functions:

* createLNSObject: A function to create a new LNS object in the database.
* getLNSObject: A function to get a specific LNS object from the database.
* getNodeForName: Construct a node(namehash output) based on the domain name.
* getKeyForNode: Get the unique database key for a specific LNS object.

===== LNS node schema

First, define an interface, which illustrates, how the LNS object will look like:

.src/app/modules/lns/data/lns_node.ts
[source,typescript]
----
export interface LNSNode {
	ownerAddress: Buffer; // <1>
	name: string;// <2>
	ttl: number;// <3>
	expiry: number;// <4>
	records: LNSNodeRecord[];// <5>
	createdAt: number;// <6>
	updatedAt: number;// <7>
}
----

<1> `ownerAddress`: The address of the domain owner as Buffer.
<2> `name`: The domain name as String.
<3> `ttl`: The TTL in seconds as number.
<4> `expiry`: The amount of years until the domain registration expires as number.
<5> `records`: A list of all existing records for this domain as <<LNS node record schema, LNSNodeRecord>>.
<6> `createdAt`: Date of the domain registration as number.
<7> `updatedAt`: Date of the last update of the domain and its' records as number.

Based on this interface, we can create the corresponding schema, which looks like this:

.src/app/modules/lns/data/lns_node.ts
[source,typescript]
----
export const lnsNodeSchema = {
	$id: 'lisk/lns/lnsNode',
	type: 'object',
	required: ['ownerAddress', 'name', 'ttl', 'expiry', 'records', 'createdAt', 'updatedAt'],
	properties: {
		ownerAddress: {
			dataType: 'bytes',
			fieldNumber: 1,
		},
		name: {
			dataType: 'string',
			fieldNumber: 2,
		},
		ttl: {
			dataType: 'uint32',
			fieldNumber: 3,
		},
		expiry: {
			dataType: 'uint32',
			fieldNumber: 4,
		},
		createdAt: {
			dataType: 'uint32',
			fieldNumber: 5,
		},
		updatedAt: {
			dataType: 'uint32',
			fieldNumber: 6,
		},
		records: {
			type: 'array',
			fieldNumber: 7,
			items: {
				...lnsNodeRecordSchema,
			},
		},
	},
};
----

===== LNS node record schema

Thee innterface for an LNS node record looks llike this:

.src/app/modules/lns/data/lns_node_records.ts
[source,typescript]
----
export interface LNSNodeRecord {
	type: number; // <1>
	label: string; // <2>
	value: string; // <3>
}
----

<1> `type`: Type of the records as number.
1 stands for a CNAME record, 2 stands for a TXT record.
<2> `label`: Label for the record.
<3> `value`: Value for the record.

Based on this interface, we can create the corresponding schema, which looks like this:

.src/app/modules/lns/data/lns_node_records.ts
[source,typescript]
----
export const lnsNodeRecordSchema = {
	$id: 'lisk/lns/lnsNodeRecord',
	type: 'object',
	required: ['type', 'label', 'value'],
	properties: {
		type: {
			dataType: 'uint32',
			fieldNumber: 1,
		},
		label: {
			dataType: 'string',
			fieldNumber: 2,
		},
		value: {
			dataType: 'string',
			fieldNumber: 3,
		}
	},
};
----

===== getNodeForName(name)

Next, import the `eth-ens-namehash` package and create the following functions:

* getNodeForName: Construct a node(namehash output) based on the domain name.
* getKeyForNode: Get the unique database key for a specific LNS object.

.src/app/modules/lns/storage.ts
[source,typescript]
----
import * as namehash from 'eth-ens-namehash';

// constants
export const LNS_PREFIX = 'LNS';
export const VALID_TLDS = ['lsk'];

// Get a unique key for each LNS object
export const getKeyForNode = (node: Buffer): string => `${LNS_PREFIX}:${node.toString('hex')}`;
// Create a hash from the domain name and return it as Buffer
export const getNodeForName = (name: string): Buffer =>
	Buffer.from(namehash.hash(name).slice(2), 'hex');
----

For the creation of the namehash output of the domain, aka node, reuse the `hash()` function of the `eth-ens-namehash` NPM package.

===== createLNSObject(stateStore, params)

Now implement the function to save a new LNS object in the database by reusing the above defined `lnsNodeSchema` and the functions `getNodeForName` and `getKeyForNode`.

The function  `createLNSObject()` expects thee following two arguments:

. `stateStore`: the stateStore which is passed from the LNS module later.
The stateStore allows to perform state changes on the blockchain.
. `params`: the parameters which will be used to create the new LNS object.
** ownerAddress
** name
** ttl
** expiry
** records

.src/app/modules/lns/storage.ts
[source,typescript]
----
import { chain, codec, StateStore } from 'lisk-sdk';
import * as namehash from 'eth-ens-namehash';

// ...

export const createLNSObject = async (
	stateStore: StateStore,
	params: Omit<LNSNode, 'createdAt' | 'updatedAt' | 'node'> & { name: string },
): Promise<void> => {
	const { name, ...lnsObject } = params;
	const node = getNodeForName(name);

	const input: LNSNode = {
		...lnsObject,
		name,
		createdAt: Math.ceil(Date.now() / 1000),
		updatedAt: Math.ceil(Date.now() / 1000),
	};

	await stateStore.chain.set(getKeyForNode(node), codec.encode(lnsNodeSchema, input));
};
----

===== getLNSObject(stateStore, node)

Next, implement the function `getLNSObject()`, which gets a specific LNS object from the database, based on the provided node value.

The function `getKeyForNode()` is used to get a unique key for the LNS object in the database.

The function  `createLNSObject()` expects thee following two arguments:

. `stateStore`: the stateStore which is passed from the LNS module later.
The stateStore allows to perform state changes on the blockchain.
. `node`: The name hash of the LNS object which is requested from the database.

.src/app/modules/lns/storage.ts
[source,typescript]
----
import { chain, codec, StateStore } from 'lisk-sdk';
import * as namehash from 'eth-ens-namehash';

// ...

export const getLNSObject = async (
	stateStore: StateStore,
	node: Buffer,
): Promise<LNSNode | undefined> => {
	const result = await stateStore.chain.get(getKeyForNode(node));

	if (!result) {
		return;
	}

	// eslint-disable-next-line consistent-return
	return codec.decode<LNSNode>(lnsNodeSchema, result);
};
----

=== Update reverse lookup

Now that the first asset is prepared, and first utility function to store and get LNS pbjbeects from the database are implemented, let's move onn to implement the second required asset for updating the reverse lookup of a domain for an account.

While 'regular' lookup involves mapping from a name to an address, reverse lookup maps from an address back to a domain.
This allows applications to display LNS names in place of hexadecimal addresses.

Because an account can register multiple domains, it is important to define, to which domain the address should resolve to by default.

To do this, the account owner needs to send a reverse lookup transaction to update the default domain, their account address should default to.

Similar to the register asset, use Lisk Commander to first generate the asset skeleton.
Use `reverse_lookup` and `2` as asset ID.

[source,bash]
----
lisk generate:asset lns reverse_lookup 2
----

==== Schema
[source,typescript]
----
export const reverseLookupAssetPropsSchema = {
  $id: 'lns/assets/set-lookup',
  title: 'SetLookup transaction asset for lns module',
  type: 'object',
  required: ['name'],
  properties: {
    name: {
      dataType: 'string',
      fieldNumber: 1,
    },
  },
}
----
==== State change
[source,typescript]
----
public async apply({
    asset,
    stateStore,
    transaction,
}: ApplyAssetContext<ReverseLookupAssetProps>): Promise<void> {
    const node = getNodeForName(asset.name);
    const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);

    const exists = sender.lns.ownNodes.find(n => n.equals(node));

    if (!exists) {
        throw new Error('You can only assign lookup node which you own.');
    }

    sender.lns.reverseLookup = node;
    await stateStore.account.set(sender.address, sender);
}
----
=== Update records

[source,bash]
----
lisk generate:asset lns update_records 3
----

==== Schema
.src/app/modules/lns/data/assets/update_records.ts
[source,typescript]
----
export const updateRecordsAssetPropsSchema = {
  $id: 'lns/assets/update-records',
  title: 'Update Records transaction asset for lns module',
  type: 'object',
  required: ['records'],
  properties: {
    name: {
      dataType: 'string',
      fieldNumber: 1,
    },
    records: {
      type: 'array',
      fieldNumber: 2,
      items: {
				...lnsNodeRecordSchema,
			},
    }
  },
}
----
==== Validation
.src/app/modules/lns/assets/update_records.ts
[source,typescript]
----
public validate({ asset }: ValidateAssetContext<UpdateRecordsAssetProps>): void {
    if (asset.records.length > MAX_RECORDS) {
        throw new Error(`Can associate maximum ${MAX_RECORDS} records. Got ${asset.records.length}.`);
    }

    const recordKeys = new Set(asset.records.map(r => `${r.type.toString()}:${r.label}`));

    if (recordKeys.size !== asset.records.length) {
        throw new Error('Records should be unique among type and label');
    }

    for (const record of asset.records) {
        if (!VALID_RECORD_TYPES.includes(record.type)) {
            throw new Error(
                `Invalid record type "${
                    record.type
                }". Valid record types are ${VALID_RECORD_TYPES.join()}`,
            );
        }

        if (
            record.label.length > MAX_RECORD_LABEL_LENGTH ||
            record.label.length < MIN_RECORD_LABEL_LENGTH
        ) {
            throw new Error(
                `Record label can be between ${MIN_RECORD_LABEL_LENGTH}-${MAX_RECORD_LABEL_LENGTH}.`,
            );
        }

        if (
            record.value.length > MAX_RECORD_VALUE_LENGTH ||
            record.value.length < MIN_RECORD_VALUE_LENGTH
        ) {
            throw new Error(
                `Record value can be between ${MIN_RECORD_VALUE_LENGTH}-${MAX_RECORD_VALUE_LENGTH}.`,
            );
        }
    }
}
----

==== State change
.src/app/modules/lns/assets/update_records.ts
[source,typescript]
----
public async apply({
    asset,
    stateStore,
    transaction,
}: ApplyAssetContext<UpdateRecordsAssetProps>): Promise<void> {
    const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);
    const node = getNodeForName(asset.name);
    const lnsObject = await getLNSObject(stateStore, node);

    if (!lnsObject) {
        throw new Error(`LNS object with name "${asset.name}" is not registered`);
    }

    if (!lnsObject.ownerAddress.equals(sender.address)) {
        throw new Error('Only owner of hte LNS object can update records.');
    }

    if (!isTTLPassed(lnsObject)) {
        throw new Error('You have to wait for TTL from the last update.');
    }

    await updateLSNObject(stateStore, { node, records: asset.records });
}
----

==== Utility functions

.src/app/modules/lns/storage.ts
[source,typescript]
----
export const updateLSNObject = async (
	stateStore: StateStore,
	params: Partial<Omit<LNSNode, 'createdAt' | 'updatedAt'>> & { node: Buffer },
): Promise<void> => {
	const lnsObject = await getLNSObject(stateStore, params.node);

	if (!lnsObject) {
		throw new Error('No lns object is associated with this name');
	}

	lnsObject.ttl = params.ttl ?? lnsObject.ttl;
	lnsObject.ownerAddress = params.ownerAddress ?? lnsObject.ownerAddress;
	lnsObject.expiry = params.expiry ?? lnsObject.expiry;
	lnsObject.records = params.records ?? lnsObject.records;

	lnsObject.updatedAt = Math.ceil(Date.now() / 1000);

	await stateStore.chain.set(getKeyForNode(params.node), codec.encode(lnsNodeSchema, lnsObject));
};
----

== Creating the LNS module
=== Assets
[source,typescript]
----
----
=== Actions
[source,typescript]
----
----
.src/app/modules/lns/storage.ts
[source,typescript]
----
----
=== Reducers
[source,typescript]
----
----
== Connecting the Dashboard plugin
[source,typescript]
----
----
== Extending the application CLI
[source,typescript]
----
----
== Using a plugin as frontend
[source,typescript]
----
----
== Writing unit tests
== Writing network tests
