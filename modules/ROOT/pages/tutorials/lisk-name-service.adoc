= Lisk Name Service (LNS) Tutorial
Mona Bärenfänger <mona@lightcurve.io>
// Settings
:toc: preamble
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
:experimental:
// URLs
:url_wikipedia_dns: https://en.wikipedia.org/wiki/Domain_Name_System
:url_ens: https://docs.ens.domains/

How to create a blockchain application that offers a domain name service for blockchain accounts, similar to {url_wikipedia_dns}[DNS^] and {url_ens}[ENS^].

This service allows an account to register one or multiple `.lsk` domains for a certain amount of time (1-5 years).

If an account registers a domain, it becomes a human readable identifier for the account and can then be used to refer to the account instead of the (less human-readable) Lisk32 account address.

Additionally, it is possible to create TXT and CNAME records for each domain owned by an account.

== LNS application overview
image:tutorials/lns/lns-overview.png[]

:sectnums:
== Dependencies

[options="header",]
|===
|Dependencies |Version
|Git | v2 (latest)
|Node.js | v12 (latest)
|Lisk Commander | v5.1.2 (latest)
|===

=== Node.js

If you are using NVM, install the correct version as shown below:

[source,bash]
----
nvm install v12.22.3
----

=== Lisk Commander

It is recommended to install Lisk Commander globally with NPM to facilitate the convenient usage of the Lisk Commander CLI.

[source,bash]
----
npm install --global lisk-commander
----

To check the successful installation of Lisk Commander, run for example:

[source,bash]
----
$ lisk --version
lisk-commander/5.1.2 darwin-x64 node-v12.22.3
----

== Bootstrapping the default application

Create a dedicated folder `lisk-name-service/`, which will contain the files for the application.

Inside of this folder, execute the `lisk init` command of Lisk Commander as shown below:

[source,bash]
----
mkdir lisk-name-service
cd lisk-name-service
lisk init
----

----
.
├── README.md
├── bin
│   ├── run
│   └── run.cmd
├── config
│   └── default
│       ├── config.json
│       └── genesis_block.json
├── jest.config.js
├── package-lock.json
├── package.json
├── src
│   ├── app
│   │   ├── app.ts
│   │   ├── index.ts
│   │   ├── modules
│   │   │   └── hello
│   │   ├── modules.ts
│   │   ├── plugins
│   │   └── plugins.ts
│   └── commands
│       ├── account
│       │   ├── create.ts
│       │   ├── get.ts
│       │   ├── show.ts
│       │   └── validate.ts
│       ├── block
│       │   └── get.ts
│       ├── blockchain
│       │   ├── export.ts
│       │   ├── hash.ts
│       │   ├── import.ts
│       │   └── reset.ts
│       ├── config
│       │   ├── create.ts
│       │   └── show.ts
│       ├── console.ts
│       ├── forger-info
│       │   ├── export.ts
│       │   └── import.ts
│       ├── forging
│       │   ├── config.ts
│       │   ├── disable.ts
│       │   ├── enable.ts
│       │   └── status.ts
│       ├── genesis-block
│       │   └── create.ts
│       ├── hash-onion.ts
│       ├── node
│       │   └── info.ts
│       ├── passphrase
│       │   ├── decrypt.ts
│       │   └── encrypt.ts
│       ├── start.ts
│       └── transaction
│           ├── create.ts
│           ├── get.ts
│           ├── send.ts
│           └── sign.ts
├── test
└── tsconfig.json
----

[source,bash]
----
lisk generate:module hello 1000
----

[source,bash]
----
lisk generate:asset hello createHello 0
----

== Creating the LNS module assets
=== Register Domain

==== Schema

.src/app/modules/lns/data/assets/register.ts
[source,typescript]
----
	$id: 'lisk/lns/lnsAccount',
	type: 'object',
	required: ['ownNodes', 'reverseLookup'],
	properties: {
		reverseLookup: {
			dataType: 'bytes',
			fieldNumber: 1,
		},
		ownNodes: {
			type: 'array',
			fieldNumber: 2,
			items: {
				dataType: 'bytes',
			},
		},
	},
	default: {
		ownNodes: [],
		reverseLookup: EMPTY_BUFFER,
	},
};
----

==== Validation

.src/app/modules/lns/assets/register.ts
[source,typescript]
----
public validate({ asset }: ValidateAssetContext<RegisterAssetProps>): void {
    if (asset.ttl < MIN_TTL_VALUE) {
        throw new Error(`Must set TTL value larger or equal to ${MIN_TTL_VALUE}`);
    }

    if (asset.registerFor < 1) {
        throw new Error('You can register name at least for 1 year.');
    }

    if (asset.registerFor > 5) {
        throw new Error('You can register name maximum for 5 year.');
    }

    const chunks = asset.name.split(/\./);

    if (chunks.length > 2) {
        throw new Error('You can only register second level domain name.');
    }

    if (!VALID_TLDS.includes(chunks[1])) {
        throw new Error(`Invalid TLD found "${chunks[1]}". Valid TLDs are "${VALID_TLDS.join()}"`);
    }
}
----

==== State change

.src/app/modules/lns/assets/register.ts
[source,typescript]
----
public async apply({
		asset,
		stateStore,
		transaction,
	}: ApplyAssetContext<RegisterAssetProps>): Promise<void> {
		const node = getNodeForName(asset.name);
		const existingDomain = await getLNSObject(stateStore, node);

		if (existingDomain) {
			throw new Error(`The name "${asset.name}" already registered`);
		}

		const lnsObject = {
			name: asset.name,
			ttl: asset.ttl,
			expiry: Math.ceil(addYears(new Date(), asset.registerFor).getTime() / 1000),
			ownerAddress: transaction.senderAddress,
			records: [],
		};

		await createLSNObject(stateStore, lnsObject);

		const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);
		sender.lns.ownNodes = [...sender.lns.ownNodes, node];
		await stateStore.account.set(sender.address, sender);
	}
}
----

==== Utility functions

.src/app/modules/lns/storage.ts
[source,typescript]
----
import * as namehash from 'eth-ens-namehash';

// constants
export const LNS_PREFIX = 'LNS';
export const VALID_TLDS = ['lsk'];

// Get a unique key for each LNS object
export const getKeyForNode = (node: Buffer): string => `${LNS_PREFIX}:${node.toString('hex')}`;
// Create a hash from the domain name and return it as Buffer
export const getNodeForName = (name: string): Buffer =>
	Buffer.from(namehash.hash(name).slice(2), 'hex');
----

.src/app/modules/lns/storage.ts
[source,typescript]
----
export const getLNSObject = async (
	stateStore: StateStore,
	node: Buffer,
): Promise<LNSNode | undefined> => {
	const result = await stateStore.chain.get(getKeyForNode(node));

	if (!result) {
		return;
	}

	// eslint-disable-next-line consistent-return
	return codec.decode<LNSNode>(lnsNodeSchema, result);
};
----

.src/app/modules/lns/storage.ts
[source,typescript]
----
export const createLSNObject = async (
	stateStore: StateStore,
	params: Omit<LNSNode, 'createdAt' | 'updatedAt' | 'node'> & { name: string },
): Promise<void> => {
	const { name, ...lnsObject } = params;
	const node = getNodeForName(name);

	const input: LNSNode = {
		...lnsObject,
		name,
		createdAt: Math.ceil(Date.now() / 1000),
		updatedAt: Math.ceil(Date.now() / 1000),
	};

	await stateStore.chain.set(getKeyForNode(node), codec.encode(lnsNodeSchema, input));
};
----

.src/app/modules/lns/data/lns_node.ts
[source,typescript]
----
export interface LNSNode {
	ownerAddress: Buffer;
	name: string;
	ttl: number;
	expiry: number;
	records: LNSNodeRecord[];
	createdAt: number;
	updatedAt: number;
}
----

.src/app/modules/lns/data/lns_node.ts
[source,typescript]
----
export const lnsNodeSchema = {
	$id: 'lisk/lns/lnsNode',
	type: 'object',
	required: ['ownerAddress', 'name', 'ttl', 'expiry', 'records', 'createdAt', 'updatedAt'],
	properties: {
		ownerAddress: {
			dataType: 'bytes',
			fieldNumber: 1,
		},
		name: {
			dataType: 'string',
			fieldNumber: 2,
		},
		ttl: {
			dataType: 'uint32',
			fieldNumber: 3,
		},
		expiry: {
			dataType: 'uint32',
			fieldNumber: 4,
		},
		createdAt: {
			dataType: 'uint32',
			fieldNumber: 5,
		},
		updatedAt: {
			dataType: 'uint32',
			fieldNumber: 6,
		},
		records: {
			type: 'array',
			fieldNumber: 7,
			items: {
				...lnsNodeRecordSchema,
			},
		},
	},
};
----

.src/app/modules/lns/data/lns_node_records.ts
[source,typescript]
----
export interface LNSNodeRecord {
	type: number;
	label: string;
	value: string;
}
----

.src/app/modules/lns/data/lns_node_records.ts
[source,typescript]
----
export const lnsNodeRecordSchema = {
	$id: 'lisk/lns/lnsNodeRecord',
	type: 'object',
	required: ['type', 'label', 'value'],
	properties: {
		type: {
			dataType: 'uint32',
			fieldNumber: 1,
		},
		label: {
			dataType: 'string',
			fieldNumber: 2,
		},
		value: {
			dataType: 'string',
			fieldNumber: 3,
		}
	},
};
----

=== Update reverse lookup
==== Schema
[source,typescript]
----
export const reverseLookupAssetPropsSchema = {
  $id: 'lns/assets/set-lookup',
  title: 'SetLookup transaction asset for lns module',
  type: 'object',
  required: ['name'],
  properties: {
    name: {
      dataType: 'string',
      fieldNumber: 1,
    },
  },
}
----
==== State change
[source,typescript]
----
public async apply({
    asset,
    stateStore,
    transaction,
}: ApplyAssetContext<ReverseLookupAssetProps>): Promise<void> {
    const node = getNodeForName(asset.name);
    const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);

    const exists = sender.lns.ownNodes.find(n => n.equals(node));

    if (!exists) {
        throw new Error('You can only assign lookup node which you own.');
    }

    sender.lns.reverseLookup = node;
    await stateStore.account.set(sender.address, sender);
}
----
=== Update records

==== Schema
.src/app/modules/lns/data/assets/update_records.ts
[source,typescript]
----
export const updateRecordsAssetPropsSchema = {
  $id: 'lns/assets/update-records',
  title: 'Update Records transaction asset for lns module',
  type: 'object',
  required: ['records'],
  properties: {
    name: {
      dataType: 'string',
      fieldNumber: 1,
    },
    records: {
      type: 'array',
      fieldNumber: 2,
      items: {
				...lnsNodeRecordSchema,
			},
    }
  },
}
----
==== Validation
.src/app/modules/lns/assets/update_records.ts
[source,typescript]
----
public validate({ asset }: ValidateAssetContext<UpdateRecordsAssetProps>): void {
    if (asset.records.length > MAX_RECORDS) {
        throw new Error(`Can associate maximum ${MAX_RECORDS} records. Got ${asset.records.length}.`);
    }

    const recordKeys = new Set(asset.records.map(r => `${r.type.toString()}:${r.label}`));

    if (recordKeys.size !== asset.records.length) {
        throw new Error('Records should be unique among type and label');
    }

    for (const record of asset.records) {
        if (!VALID_RECORD_TYPES.includes(record.type)) {
            throw new Error(
                `Invalid record type "${
                    record.type
                }". Valid record types are ${VALID_RECORD_TYPES.join()}`,
            );
        }

        if (
            record.label.length > MAX_RECORD_LABEL_LENGTH ||
            record.label.length < MIN_RECORD_LABEL_LENGTH
        ) {
            throw new Error(
                `Record label can be between ${MIN_RECORD_LABEL_LENGTH}-${MAX_RECORD_LABEL_LENGTH}.`,
            );
        }

        if (
            record.value.length > MAX_RECORD_VALUE_LENGTH ||
            record.value.length < MIN_RECORD_VALUE_LENGTH
        ) {
            throw new Error(
                `Record value can be between ${MIN_RECORD_VALUE_LENGTH}-${MAX_RECORD_VALUE_LENGTH}.`,
            );
        }
    }
}
----

==== State change
.src/app/modules/lns/assets/update_records.ts
[source,typescript]
----
public async apply({
    asset,
    stateStore,
    transaction,
}: ApplyAssetContext<UpdateRecordsAssetProps>): Promise<void> {
    const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);
    const node = getNodeForName(asset.name);
    const lnsObject = await getLNSObject(stateStore, node);

    if (!lnsObject) {
        throw new Error(`LNS object with name "${asset.name}" is not registered`);
    }

    if (!lnsObject.ownerAddress.equals(sender.address)) {
        throw new Error('Only owner of hte LNS object can update records.');
    }

    if (!isTTLPassed(lnsObject)) {
        throw new Error('You have to wait for TTL from the last update.');
    }

    await updateLSNObject(stateStore, { node, records: asset.records });
}
----

==== Utility functions

.src/app/modules/lns/storage.ts
[source,typescript]
----
export const updateLSNObject = async (
	stateStore: StateStore,
	params: Partial<Omit<LNSNode, 'createdAt' | 'updatedAt'>> & { node: Buffer },
): Promise<void> => {
	const lnsObject = await getLNSObject(stateStore, params.node);

	if (!lnsObject) {
		throw new Error('No lns object is associated with this name');
	}

	lnsObject.ttl = params.ttl ?? lnsObject.ttl;
	lnsObject.ownerAddress = params.ownerAddress ?? lnsObject.ownerAddress;
	lnsObject.expiry = params.expiry ?? lnsObject.expiry;
	lnsObject.records = params.records ?? lnsObject.records;

	lnsObject.updatedAt = Math.ceil(Date.now() / 1000);

	await stateStore.chain.set(getKeyForNode(params.node), codec.encode(lnsNodeSchema, lnsObject));
};
----

== Creating the LNS module
=== Assets
[source,typescript]
----
----
=== Actions
[source,typescript]
----
----
.src/app/modules/lns/storage.ts
[source,typescript]
----
----
=== Reducers
[source,typescript]
----
----
== Connecting the Dashboard plugin
[source,typescript]
----
----
== Extending the application CLI
[source,typescript]
----
----
== Using a plugin as frontend
[source,typescript]
----
----
== Writing unit tests
== Writing network tests
