= Lisk Name Service (LNS) Tutorial
Mona Bärenfänger <mona@lightcurve.io>
// Settings
:toc: preamble
:toclevels: 4
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
:experimental:
// URLs
:url_wikipedia_dns: https://en.wikipedia.org/wiki/Domain_Name_System
:url_wikipedia_cname: https://en.wikipedia.org/wiki/CNAME_record
:url_wikipedia_txt: https://en.wikipedia.org/wiki/TXT_record
:url_recaptcha_keys: https://developers.google.com/recaptcha/docs/faq#id-like-to-run-automated-tests-with-recaptcha.-what-should-i-do
:url_ens: https://docs.ens.domains/
:url_faucet: http://localhost:4004
:url_dashboard: http://localhost:4005
:url_oclif: https://oclif.io/
:url_sdk_dashboardplugin: https://github.com/LiskHQ/lisk-sdk/tree/v5.1.4/framework-plugins/lisk-framework-dashboard-plugin
:url_sdk_baseipcclient: https://github.com/LiskHQ/lisk-sdk/blob/v5.1.4/commander/src/bootstrapping/commands/base_ipc_client.ts
:url_sdkexamples_lns_secret: https://github.com/LiskHQ/lisk-sdk-examples/tree/development/tutorials/lisk-name-service/lns/.secret
:url_sdkexamples_lns_uiplugin: https://github.com/LiskHQ/lisk-sdk-examples/tree/development/tutorials/lisk-name-service/lns-dashboard-plugin
:url_reactjs: https://reactjs.org/docs/create-a-new-react-app.html#create-react-app
:url_reactjs_docs: https://reactjs.org/docs/create-a-new-react-app.html
// Project URLs
:url_guide_dashboard: guides/app-development/dashboard.adoc
:url_guide_genesisblock: guides/app-development/genesis-block.adoc
:url_reference_dashboard: references/lisk-framework/dashboard-plugin.adoc
:url_reference_testsuite: references/lisk-framework/test-suite.adoc
:url_reference_faucet: references/lisk-framework/faucet-plugin.adoc
:url_bapps_frontend: introduction/blockchain-applications.adoc#frontend-backend
:url_test_suite_createvalidatecontext: references/lisk-framework/test-suite.adoc#returns-25
:url_test_suite_createapplycontext: references/lisk-framework/test-suite.adoc#returns-26

How to create a blockchain application that offers a domain name service for blockchain accounts, similar to {url_wikipedia_dns}[DNS^] and {url_ens}[ENS^].

This service allows an account to register one or multiple `.lsk` domains for a certain amount of time (1-5 years).

If an account registers a domain, it becomes a human readable identifier for the account and can then be used to refer to the account instead of the (less human-readable) Lisk32 account address.

Additionally, it is possible to create TXT and CNAME records for each domain owned by an account.

== LNS application overview
image:tutorials/lns/lns-overview.png[]

:sectnums:
== Dependencies

[options="header",]
|===
|Dependencies |Version
|Git | v2 (latest)
|Node.js | v12 (latest)
|Lisk Commander | v5.1 (latest)
|===

=== Node.js

If you are using NVM, install the correct version as shown below:

[source,bash]
----
nvm install v12.22.3
----

=== Lisk Commander

It is recommended to install Lisk Commander globally with NPM to facilitate the convenient usage of the Lisk Commander CLI.

[source,bash]
----
npm install --global lisk-commander
----

To check the successful installation of Lisk Commander, run for example:

[source,bash]
----
$ lisk --version
lisk-commander/5.1.5 darwin-x64 node-v12.22.3
----

== Bootstrapping the default application

Create a dedicated folder `lisk-name-service/`, which will contain the files for the application.

Inside of this folder, execute the `lisk init` command of Lisk Commander as shown below:

[source,bash]
----
mkdir lisk-name-service
cd lisk-name-service
lisk init
----

Next you will be prompted for the application name, description, author and license.

----
Using template "lisk-ts"
Initializing git repository
Updating .liskrc.json file
Creating project structure
? Application name lns
? Application description My blockchain application
? Author yourName
? License ISC
----

This will generate a lot of new files and folders, resulting in the following structure:

----
.
├── README.md
├── bin <1>
├── config <2>
├── jest.config.js
├── package-lock.json
├── package.json
├── src
│   ├── app <3>
│   │   ├── app.ts <4>
│   │   ├── index.ts
│   │   ├── modules <5>
│   │   ├── modules.ts <6>
│   │   ├── plugins <7>
│   │   └── plugins.ts <8>
│   └── commands <9>
├── test <10>
└── tsconfig.json
----

<1> `bin/` contains the `run` script which starts the application CLI.
<2> `config/` contains the default configuration and genesis block for the application.
<3> `app/` contains the files of the blockchain application.
<4> `app.ts` creates the `Application` instance.
<5> `modules/` contains the application modules (currently empty).
<6> `modules.ts` registers the modules with the application.
<7> `plugins/` contains the application plugins (currently empty).
<8> `plugins.ts` registers the plugins with the application.
<9> `commands/` contains the application CLI commands.
<10> `test/` contains functional, network and unit tests for the blockchain application.

These files create a ready-to-start blockchain application, configured for a local devnet, which uses only the default modules of the Lisk SDK.

The application is created in the file `app.ts`:

.src/app/app.ts
[source,typescript]
----
import { Application, PartialApplicationConfig, utils } from 'lisk-sdk';
import { registerModules } from './modules';
import { registerPlugins } from './plugins';

export const getApplication = (
	genesisBlock: Record<string, unknown>,
	config: PartialApplicationConfig,
): Application => {
	const app = Application.defaultApplication(genesisBlock, config); // <1>

	registerModules(app); // <2>
	registerPlugins(app); // <3>

	return app;
};
----

<1> Creates blockchain application with the default modules.
<2> Will register additional modules to the application.
Currently, no additional modules are available for the application.
To add new modules update the `modules.ts` file.
<3> Will register additional plugins to the application.
Currently, no plugins are available for the application.
To add new plugins update the `plugins.ts` file.

To verify the successful bootstrap of the blockchain application, start it with the following command:

.lisk-name-service/
[source,bash]
----
./bin/run start
----

This should start the LNS blockchain application, which is currently running with a local single-node development network.

Observe the displayed log messages in the console.
If no errors are thrown, the application will start to add new logs every 10 seconds after the initial startup.

Once it is verified that the application runs correctly, stop the node again with kbd:[Ctrl] + kbd:[C].

After the application was started for the first time, the corresponding application data can be found under the path `~/.lisk/lns/`

.~/.lisk/lns/
----
.
├── config
│   └── default
│       ├── config.json <1>
│       └── genesis_block.json <2>
├── data  <3>
│   ├── blockchain.db
│   ├── forger.db
│   ├── genesis_block_compiled
│   └── node.db
├── logs  <4>
│   ├── lisk.log
│   ├── plugin-LnsDashboard.log
│   ├── plugin-forger.log
│   └── plugin-httpApi.log
├── plugins <5>
│   └── data
└── tmp <6>
    ├── pids
    └── sockets
----

<1> `config.json` is the configuration file of the blockchain application.
<2> `genesis_block.json` is the genesis block of the blockchain application.
<3> `data` contains all on-chain data of the blockchain, stored in key-value stores.
<4> `logs` contains the file logs of the application and its' plugins.
<5> `plugins` contains all off-chain data of the application, stored in key-value-stores.
<6> `tmp` contains temporary application data.

To customize the default blockchain application to suit our desired use case, we will now generate the LNS module skeleton.

Create the module skeleton by executing the command `lisk generate:module` like shown below:

.lisk-name-service/
[source,bash]
----
lisk generate:module lns 1000
----

The command expects two arguments:

 . The module name
 . The module ID

This will information will be used to create the corresponding module skeleton.

----
├── src
│   ├── app
│   │   ├── app.ts
│   │   ├── index.ts
│   │   ├── modules
│   │   │   └── lns.ts
│   │   │       └── lns_module.ts <1>
│   │   ├── modules.ts
│   │   ├── plugins
│   │   └── plugins.ts
----

<1> The newly created skeleton for the LNS module

Read the following sections to learn how to further extend the LNS module to suit the desired use case.

== Creating the LNS module assets

The first part of the module that we implement here are the assets to handle the different transaction types `register`, `reverse lookup` and `update records`.

=== Register Domain

As first step for creating the asset, use Lisk Commander again, this time, to create the asset skeleton.

Execute the following command:

.lisk-name-service/
[source,bash]
----
lisk generate:asset lns register 1
----

----
├── src
│   ├── app
│   │   ├── app.ts
│   │   ├── index.ts
│   │   ├── modules
│   │   │   └── lns.ts
│   │   │       ├── assets
│   │   │       │   └── register.ts <1>
│   │   │       └── lns_module.ts
│   │   ├── modules.ts
│   │   ├── plugins
│   │   └── plugins.ts
----

<1> The newly created skeleton for the `register` asset.

When you open `register.ts` at this point, it will look like this:

.src/app/modules/lns/assets/register.ts
[source,typescript]
----
import { BaseAsset, ApplyAssetContext, ValidateAssetContext } from 'lisk-sdk';

export class RegisterAsset extends BaseAsset {
  public name = 'register';
  public id = 1;

  // Define schema for asset
	public schema = {
    $id: 'lns/register-asset',
		title: 'RegisterAsset transaction asset for lns module',
		type: 'object',
		required: [],
		properties: {},
  };

  public validate({ asset }: ValidateAssetContext<{}>): void {
    // Validate your asset
  }

	// eslint-disable-next-line @typescript-eslint/require-await
  public async apply({ asset, transaction, stateStore }: ApplyAssetContext<{}>): Promise<void> {
		throw new Error('Asset "register" apply hook is not implemented.');
	}
}
----

As you can see, the asset name and ID are already pre-filled with the values we provided when creating the asset skeleton.

As next step, we want to define the asset schema, which defines which kind of data is expected by the application to successfully register a new domain for a user account.

==== Schema

Create a new folder `data/` inside the `lns` module folder.

.src/app/modules/lns/
[source,bash]
----
mkdir data
----

This folder is created to maintain a better overview, and will store all account and asset schemas which are relevant to the LNS module.

.src/app/modules/lns/
[source,bash]
----
mkdir data/assets
----

Inside the `data/assets` folder, create a new file `register.ts`, which will contain the schemas related to the `register` asset.

The first thing we define in the file, is an interface  for the expected asset data of a `register` transaction.
It describes in a straight-forward way, what data is expected to be in the transaction asset for a successful registration of a new domain.

The following information is required for a successful registration:

* `name`(string): The domain name to register for the sending account.
* `ttl`(number): Time-To-Live: Time which needs to pass, until the records for the domain can be updated again.
* `registerFor`(number): The duration to reserve this domain for the sender account.

The corresponding interface looks like this:

.src/app/modules/lns/data/assets/register.ts
[source,typescript]
----
export interface RegisterAssetProps {
	name: string;
	ttl: number;
	registerFor: number;
}
----

This is described in the following asset schema, which is shown below:

.src/app/modules/lns/data/assets/register.ts
[source,typescript]
----
export const registerAssetPropsSchema = {
  $id: 'lns/assets/register',
  title: 'RegisterAsset transaction asset for lns module',
  type: 'object',
  required: ['name', 'ttl', 'registerFor'],
  properties: {
    name: {
      dataType: 'string',
      fieldNumber: 1,
    },
    ttl: {
      dataType: 'uint32',
      fieldNumber: 2,
    },
    registerFor: {
      dataType: 'uint32',
      fieldNumber: 3,
    },
  },
}
----

Add the interface and asset schema to the file and save it.

Now,  just include the schema in the asset file:

.src/app/modules/lns/assets/register.ts
[source,typescript]
----
import { BaseAsset, ApplyAssetContext, ValidateAssetContext } from 'lisk-sdk';
import { RegisterAssetProps, registerAssetPropsSchema } from '../data';

export class RegisterAsset extends BaseAsset<RegisterAssetProps> {
  public name = 'register';
  public id = 1;

  // Define schema for asset
  public schema = registerAssetPropsSchema;

  // ...
}
----

==== Validation

Create a new file `constants.ts` inside the `lns` module folder.

This file is created to maintain a better overview, and will store all constants which are relevant to the LNS module and its' assets.

Add the following two constants.

.src/app/modules/lns/constants.ts
[source,typescript]
----
export const MIN_TTL_VALUE = 60 * 60; // 1 hour
export const VALID_TLDS = ['lsk'];
----

Now import the constants into the `register` asset, and use them to check the validity of transaction assets:

We want to validate the following:

. The TTL value needs to be above the minimum defined TTL value (60 * 60).
. The `registerFor` value needs to be between 1 and 5.
. Only second level domain names can be registered.
. Only domains with valid TLDs can be registered.

The corresponding checks look like this:

.src/app/modules/lns/assets/register.ts
[source,typescript]
----
import { BaseAsset, ApplyAssetContext, ValidateAssetContext } from 'lisk-sdk';
import { RegisterAssetProps, registerAssetPropsSchema } from '../data';
import { MIN_TTL_VALUE, VALID_TLDS } from '../constants';

export class RegisterAsset extends BaseAsset<RegisterAssetProps> {

    // ...

  public validate({ asset }: ValidateAssetContext<RegisterAssetProps>): void {
		if (asset.ttl < MIN_TTL_VALUE) {
			throw new Error(`Must set TTL value larger or equal to ${MIN_TTL_VALUE}`);
		}

		if (asset.registerFor < 1) {
			throw new Error('You can register name at least for 1 year.');
		}

		if (asset.registerFor > 5) {
			throw new Error('You can register name maximum for 5 year.');
		}

		const chunks = asset.name.split(/\./);

		if (chunks.length > 2) {
			throw new Error('You can only register second level domain name.');
		}

		if (!VALID_TLDS.includes(chunks[1])) {
			throw new Error(`Invalid TLD found "${chunks[1]}". Valid TLDs are "${VALID_TLDS.join()}"`);
		}
	}

    // ...
}
----

==== State change

If the validation of the transaction asset doesn't throw any errors, the `apply()` function is executed, which allows state changes on the blockchain, based on the received transaction data.

The following logic is implemented in the `apply()` function:

* Checks, if the domain name was already registered, and throws an error in this case.
* Creates a new LNS object based on the asset data of the received transaction and saves it in the blockchain.
* Adds the namehash output of the domain name to the sender account under the key `lns.ownNodes`.

.src/app/modules/lns/assets/register.ts
[source,typescript]
----
import { addYears } from 'date-fns';
import { BaseAsset, ApplyAssetContext, ValidateAssetContext } from 'lisk-sdk';
import { LNSAccountProps, RegisterAssetProps, registerAssetPropsSchema } from '../data';
import { createLNSObject, getLNSObject, getNodeForName } from '../storage';
import { MIN_TTL_VALUE, VALID_TLDS } from '../constants';

export class RegisterAsset extends BaseAsset<RegisterAssetProps> {

    // ...

    public async apply({
            asset,
            stateStore,
            transaction,
        }: ApplyAssetContext<RegisterAssetProps>): Promise<void> {
            // Get namehash output of the domain anme
            const node = getNodeForName(asset.name);

            // Check if this domain is already registered on the blockchain
            const existingDomain = await getLNSObject(stateStore, node);
            if (existingDomain) {
                throw new Error(`The name "${asset.name}" already registered`);
            }

            // Create the LNS object and save it on the blockchain
            const lnsObject = {
                name: asset.name,
                ttl: asset.ttl,
                expiry: Math.ceil(addYears(new Date(), asset.registerFor).getTime() / 1000),
                ownerAddress: transaction.senderAddress,
                records: [],
            };
            await createLNSObject(stateStore, lnsObject);

            // Get the sender account
            const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);

            // Add the namehash output of the domain to the sender account
            sender.lns.ownNodes = [...sender.lns.ownNodes, node];

            // Save the updated sender account on the blockchain
            await stateStore.account.set(sender.address, sender);
        }
    }

    // ...
}
----

Several utility functions are used inside of the apply function, which are implemented in a new file under the path `src/app/modules/lns/storage.ts`.
The implementation of these functions is explained in the next section in detail.

The `LNSAccountProps` are imported from the `lns/data/` folder.
Create a new file `lns/data/account_props.ts` which exports the `LNSAccountProps`:

.src/app/modules/lns/data/account_props.ts
[source,typescript]
----
import { EMPTY_BUFFER } from "../constants";

export interface LNSAccountProps {
	lns: {
		ownNodes: Buffer[];
		reverseLookup: Buffer;
	};
}

export const lsnAccountPropsSchema = {
	$id: 'lisk/lns/lnsAccount',
	type: 'object',
	required: ['ownNodes', 'reverseLookup'],
	properties: {
		reverseLookup: {
			dataType: 'bytes',
			fieldNumber: 1,
		},
		ownNodes: {
			type: 'array',
			fieldNumber: 2,
			items: {
				dataType: 'bytes',
			},
		},
	},
	default: {
		ownNodes: [],
		reverseLookup: EMPTY_BUFFER,
	},
};

----

Next, open the file `lns/constants.ts`, which was created in step <<validation>> and add the following constant:

.src/app/modules/lns/constants.ts
[source,typescript]
----
export const EMPTY_BUFFER = Buffer.alloc(0);
----

==== Utility functions

Create a new file `storage.ts` in the LNS module folder.

Implement the following functions:

* <<getnodefornamename>>: Construct a node(namehash output) based on the domain name.
* <<createlnsobjectstatestore-params>>: A function to create a new LNS object in the database.
* <<getlnsobjectstatestore-node>>: A function to get a specific LNS object from the database.

===== getNodeForName(name)

Import the `eth-ens-namehash` package and create the following functions:

* getNodeForName: Construct a node(namehash output) based on the domain name.
* getKeyForNode: Get the unique database key for a specific LNS object.

.src/app/modules/lns/storage.ts
[source,typescript]
----
import * as namehash from 'eth-ens-namehash';

// constants
export const LNS_PREFIX = 'LNS';
export const VALID_TLDS = ['lsk'];

// Get a unique key for each LNS object
export const getKeyForNode = (node: Buffer): string => `${LNS_PREFIX}:${node.toString('hex')}`;
// Create a hash from the domain name and return it as Buffer
export const getNodeForName = (name: string): Buffer =>
	Buffer.from(namehash.hash(name).slice(2), 'hex');
----

For the creation of the namehash output of the domain, aka node, reuse the `hash()` function of the `eth-ens-namehash` NPM package.

===== createLNSObject(stateStore, params)

Now implement the function to save a new LNS object in the database by reusing the above defined `lnsNodeSchema` and the functions `getNodeForName` and `getKeyForNode`.

The function  `createLNSObject()` expects the following two arguments:

. `stateStore`: the stateStore which is passed from the LNS module later.
The stateStore allows to perform state changes on the blockchain.
. `params`: the parameters which will be used to create the new LNS object.
** ownerAddress
** name
** ttl
** expiry
** records

.src/app/modules/lns/storage.ts
[source,typescript]
----
import { chain, codec, StateStore } from 'lisk-sdk';
import * as namehash from 'eth-ens-namehash';

// ...

export const createLNSObject = async (
	stateStore: StateStore,
	params: Omit<LNSNode, 'createdAt' | 'updatedAt' | 'node'> & { name: string },
): Promise<void> => {
	const { name, ...lnsObject } = params;
	const node = getNodeForName(name);

	const input: LNSNode = {
		...lnsObject,
		name,
		createdAt: Math.ceil(Date.now() / 1000),
		updatedAt: Math.ceil(Date.now() / 1000),
	};

	await stateStore.chain.set(getKeyForNode(node), codec.encode(lnsNodeSchema, input));
};
----

===== getLNSObject(stateStore, node)

Next, implement the function `getLNSObject()`, which gets a specific LNS object from the database, based on the provided node value.

The function `getKeyForNode()` is used to get a unique key for the LNS object in the database.

The function `getLNSObject()` expects the following two arguments:

. `stateStore`: the stateStore which is passed from the LNS module later.
The stateStore allows to perform state changes on the blockchain.
. `node`: The name hash of the LNS object which is requested from the database.

.src/app/modules/lns/storage.ts
[source,typescript]
----
import { chain, codec, StateStore } from 'lisk-sdk';
import * as namehash from 'eth-ens-namehash';

// ...

export const getLNSObject = async (
	stateStore: StateStore,
	node: Buffer,
): Promise<LNSNode | undefined> => {
	const result = await stateStore.chain.get(getKeyForNode(node));

	if (!result) {
		return;
	}

	// eslint-disable-next-line consistent-return
	return codec.decode<LNSNode>(lnsNodeSchema, result);
};
----

==== Schemas
Implement the following interfaces and schemas, which are be used inside the utility functions:

* <<lns-node-record-schema>>: Interface and schema for an LNS node record.
* <<lns-node-schema>>: Interface and schema for an LNS node.

===== LNS node record schema

Create a new file `data/lns_node_records.ts` in the LNS module folder.

The interface for an LNS node record looks like this:

.src/app/modules/lns/data/lns_node_records.ts
[source,typescript]
----
export interface LNSNodeRecord {
	type: number; // <1>
	label: string; // <2>
	value: string; // <3>
}

export type LNSNodeRecordJSON = LNSNodeRecord;
----

<1> `type`: Type of the records as number.
`1` stands for a CNAME record, `2` stands for a TXT record.
<2> `label`: Label for the record.
<3> `value`: Value for the record.

Based on this interface, we can create the corresponding schema, which looks like this:

.src/app/modules/lns/data/lns_node_records.ts
[source,typescript]
----
export const lnsNodeRecordSchema = {
	$id: 'lisk/lns/lnsNodeRecord',
	type: 'object',
	required: ['type', 'label', 'value'],
	properties: {
		type: {
			dataType: 'uint32',
			fieldNumber: 1,
		},
		label: {
			dataType: 'string',
			fieldNumber: 2,
		},
		value: {
			dataType: 'string',
			fieldNumber: 3,
		}
	},
};
----

===== LNS node schema

Create a new file `data/lns_node.ts` in the LNS module folder.

First define an interface which illustrates, how the LNS object will look like:

.src/app/modules/lns/data/lns_node.ts
[source,typescript]
----
export interface LNSNode {
	ownerAddress: Buffer; // <1>
	name: string;// <2>
	ttl: number;// <3>
	expiry: number;// <4>
	records: LNSNodeRecord[];// <5>
	createdAt: number;// <6>
	updatedAt: number;// <7>
}
----

<1> `ownerAddress`: The address of the domain owner as Buffer.
<2> `name`: The domain name as String.
<3> `ttl`: The TTL in seconds as number.
<4> `expiry`: The amount of years until the domain registration expires as number.
<5> `records`: A list of all existing records for this domain as <<LNS node record schema, LNSNodeRecord>>.
<6> `createdAt`: Date of the domain registration as number.
<7> `updatedAt`: Date of the last update of the domain and its' records as number.

Based on this interface, we can create the corresponding schema, which looks like this:

.src/app/modules/lns/data/lns_node.ts
[source,typescript]
----
export const lnsNodeSchema = {
	$id: 'lisk/lns/lnsNode',
	type: 'object',
	required: ['ownerAddress', 'name', 'ttl', 'expiry', 'records', 'createdAt', 'updatedAt'],
	properties: {
		ownerAddress: {
			dataType: 'bytes',
			fieldNumber: 1,
		},
		name: {
			dataType: 'string',
			fieldNumber: 2,
		},
		ttl: {
			dataType: 'uint32',
			fieldNumber: 3,
		},
		expiry: {
			dataType: 'uint32',
			fieldNumber: 4,
		},
		createdAt: {
			dataType: 'uint32',
			fieldNumber: 5,
		},
		updatedAt: {
			dataType: 'uint32',
			fieldNumber: 6,
		},
		records: {
			type: 'array',
			fieldNumber: 7,
			items: {
				...lnsNodeRecordSchema,
			},
		},
	},
};
----

=== Update reverse lookup

Now that the first asset is prepared, and first utility function to store and get LNS objects from the database are implemented, let's move on to implement the second required asset for updating the reverse lookup of a domain for an account.

While 'regular' lookup involves mapping from a name to an address, reverse lookup maps from an address back to a domain.
This allows applications to display LNS names in place of hexadecimal addresses.

Because an account can register multiple domains, it is important to define, to which domain the address should resolve to by default.

To do this, the account owner needs to send a reverse lookup transaction to update the default domain, their account address should default to.

Similar to the register asset, use Lisk Commander to first generate the asset skeleton.
Use `reverse_lookup`  as asset name and `2` as asset ID.

[source,bash]
----
lisk generate:asset lns reverse_lookup 2
----

==== Schema

Create a new file und the path `src/app/modules/lns/data/assets/reverse_lookup.ts` and add the asset schema for the reverse lookup transaction.

[source,typescript]
----
export interface ReverseLookupAssetProps {
	name: string;
}

export const reverseLookupAssetPropsSchema = {
  $id: 'lns/assets/set-lookup',
  title: 'SetLookup transaction asset for lns module',
  type: 'object',
  required: ['name'],
  properties: {
    name: {
      dataType: 'string',
      fieldNumber: 1,
    },
  },
}
----

Add the interface and asset schema to the file and save it.

Now include the schema in the asset file:

.src/app/modules/lns/assets/reverse_lookup.ts
[source,typescript]
----
import { ApplyAssetContext, BaseAsset } from 'lisk-sdk';
import { LNSAccountProps, ReverseLookupAssetProps, reverseLookupAssetPropsSchema } from '../data';
import { getNodeForName } from '../storage';

export class ReverseLookupAsset extends BaseAsset<ReverseLookupAssetProps> {
	public name = 'reverse-lookup';
	public id = 2;

	// Define schema for asset
	public schema = reverseLookupAssetPropsSchema;

  // ...
}
----

==== State change

The validation is not required for the reverse lookup transaction asset, so we can directly move on to implement the apply()` function.

The following logic is implemented:

* Check, if the domain name was already registered and if the transaction sender owns this domain, and throw an error if not.
* Add the hash value of the domain as reverse lookup domain to the senders account under the key `lns.reverseLookup`.

.src/app/modules/lns/assets/reverse_lookup.ts
[source,typescript]
----
public async apply({
    asset,
    stateStore,
    transaction,
}: ApplyAssetContext<ReverseLookupAssetProps>): Promise<void> {
    const node = getNodeForName(asset.name);
    const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);

    const exists = sender.lns.ownNodes.find(n => n.equals(node));

    if (!exists) {
        throw new Error('You can only assign lookup node which you own.');
    }

    sender.lns.reverseLookup = node;
    await stateStore.account.set(sender.address, sender);
}
----

=== Update records

Finally, create the asset for updating the records of a domain.
This is the last of the three assets in the LNS module.

[TIP]

The {url_wikipedia_cname}[CNAME^] and {url_wikipedia_txt}[TXT^] records have no distinct difference in the LNS blockchain application.
A different handling of the records can be implemented at later stage.
I.e. if you build any DNS provider service on top of the LNS app, then you can use CNAME and TXT records differently there.

[source,bash]
----
lisk generate:asset lns update_records 3
----

==== Schema

Create a new file for schemas under the path `lns/data/assets/update_records.ts` and paste the asset schema for the "update records" transaction.

.src/app/modules/lns/data/assets/update_records.ts
[source,typescript]
----
import { LNSNodeRecord, lnsNodeRecordSchema } from "../lns_node_record";

export interface UpdateRecordsAssetProps {
  name: string;
  records: LNSNodeRecord[];
}

export const updateRecordsAssetPropsSchema = {
  $id: 'lns/assets/update-records',
  title: 'Update Records transaction asset for lns module',
  type: 'object',
  required: ['records'],
  properties: {
    name: {
      dataType: 'string',
      fieldNumber: 1,
    },
    records: {
      type: 'array',
      fieldNumber: 2,
      items: {
				...lnsNodeRecordSchema,
			},
    }
  },
}
----

Now include the schema in the asset file.

.src/app/modules/lns/assets/reverse_lookup.ts
[source,typescript]
----
import { ApplyAssetContext, BaseAsset, ValidateAssetContext } from 'lisk-sdk';
import { LNSAccountProps, UpdateRecordsAssetProps, updateRecordsAssetPropsSchema } from '../data';

export class UpdateRecordsAsset extends BaseAsset<UpdateRecordsAssetProps> {
	public name = 'update-records';
	public id = 3;

	// Define schema for asset
	public schema = updateRecordsAssetPropsSchema;

  // ...
}
----

==== Validation

Open the file `lns/constants.ts`, which was created in step <<validation>>, and add the following constants:

.src/app/modules/lns/constants.ts
[source,typescript]
----
export const VALID_RECORD_TYPES = [CNAME_RECORD_TYPE, TXT_RECORD_TYPE];
export const MAX_RECORDS = 50;
export const MIN_RECORD_LABEL_LENGTH = 3;
export const MAX_RECORD_LABEL_LENGTH = 15;
export const MIN_RECORD_VALUE_LENGTH = 3;
export const MAX_RECORD_VALUE_LENGTH = 255;
----

Then, import the constants inside of `update_records.ts` and implement the `validate` function as follows:

.src/app/modules/lns/assets/update_records.ts
[source,typescript]
----
import { ApplyAssetContext, BaseAsset, ValidateAssetContext } from 'lisk-sdk';
import {
	MAX_RECORDS,
	MAX_RECORD_LABEL_LENGTH,
	MAX_RECORD_VALUE_LENGTH,
	MIN_RECORD_LABEL_LENGTH,
	MIN_RECORD_VALUE_LENGTH,
	VALID_RECORD_TYPES,
} from '../constants';
import { LNSAccountProps, UpdateRecordsAssetProps, updateRecordsAssetPropsSchema } from '../data';

export class UpdateRecordsAsset extends BaseAsset<UpdateRecordsAssetProps> {
	public name = 'update-records';
	public id = 3;

	// Define schema for asset
	public schema = updateRecordsAssetPropsSchema;

	// Define asset validation
	public validate({ asset }: ValidateAssetContext<UpdateRecordsAssetProps>): void {
	    // Check, if number of records to be updated is below the maximum allowed amount (here: MAX_RECORDS = 50)
		if (asset.records.length > MAX_RECORDS) {
			throw new Error(`Can associate maximum ${MAX_RECORDS} records. Got ${asset.records.length}.`);
		}

		const recordKeys = new Set(asset.records.map(r => `${r.type.toString()}:${r.label}`));

		// Checks if all records are unique
		if (recordKeys.size !== asset.records.length) {
			throw new Error('Records should be unique among type and label');
		}

		for (const record of asset.records) {
		    // Checks if all records have valid record types
			if (!VALID_RECORD_TYPES.includes(record.type)) {
				throw new Error(
					`Invalid record type "${
						record.type
					}". Valid record types are ${VALID_RECORD_TYPES.join()}`,
				);
			}
			// Checks, if record labels have a valid length
			if (
				record.label.length > MAX_RECORD_LABEL_LENGTH ||
				record.label.length < MIN_RECORD_LABEL_LENGTH
			) {
				throw new Error(
					`Record label can be between ${MIN_RECORD_LABEL_LENGTH}-${MAX_RECORD_LABEL_LENGTH}.`,
				);
			}
            // Checks, if record values have a valid length
			if (
				record.value.length > MAX_RECORD_VALUE_LENGTH ||
				record.value.length < MIN_RECORD_VALUE_LENGTH
			) {
				throw new Error(
					`Record value can be between ${MIN_RECORD_VALUE_LENGTH}-${MAX_RECORD_VALUE_LENGTH}.`,
				);
			}
		}
	}

    // ...
}
----

==== State change


.src/app/modules/lns/assets/update_records.ts
[source,typescript]
----
import { ApplyAssetContext, BaseAsset, ValidateAssetContext } from 'lisk-sdk';
import {
	MAX_RECORDS,
	MAX_RECORD_LABEL_LENGTH,
	MAX_RECORD_VALUE_LENGTH,
	MIN_RECORD_LABEL_LENGTH,
	MIN_RECORD_VALUE_LENGTH,
	VALID_RECORD_TYPES,
} from '../constants';
import { LNSAccountProps, UpdateRecordsAssetProps, updateRecordsAssetPropsSchema } from '../data';
import { getLNSObject, updateLNSObject, getNodeForName } from '../storage';
import { isTTLPassed } from '../utils';

export class UpdateRecordsAsset extends BaseAsset<UpdateRecordsAssetProps> {
	public name = 'update-records';
	public id = 3;

	// ...

	public async apply({
		asset,
		stateStore,
		transaction,
	}: ApplyAssetContext<UpdateRecordsAssetProps>): Promise<void> {
	    // Get the sender account from the database
		const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);
		// Get the hash of the name
		const node = getNodeForName(asset.name);
		// Get the LNS object from the database
		const lnsObject = await getLNSObject(stateStore, node);
		// Validate, if the corresponding LNS object exists
		if (!lnsObject) {
			throw new Error(`LNS object with name "${asset.name}" is not registered`);
		}
        // Validate, that the sender registered the LNS object
		if (!lnsObject.ownerAddress.equals(sender.address)) {
			throw new Error('Only owner of hte LNS object can update records.');
		}
        // Validate, that the TTL for this LNS object to update the records has passed
		if (!isTTLPassed(lnsObject)) {
			throw new Error('You have to wait for TTL from the last update.');
		}
        // Update the LNS object with the new records from the asset
		await updateLNSObject(stateStore, { node, records: asset.records });
	}

}
----

The function `updateLNSObject()` is a new function which is added to the utility functions in the next section.

==== Utility functions

Open the file `storage.ts` which was previously created in step <<utility-functions>>, and define a new function `updateLSNObject()` which updates a certain LNS object in the database, based on provided parameters.

.src/app/modules/lns/storage.ts
[source,typescript]
----
export const updateLSNObject = async (
	stateStore: StateStore,
	params: Partial<Omit<LNSNode, 'createdAt' | 'updatedAt'>> & { node: Buffer },
): Promise<void> => {
	const lnsObject = await getLNSObject(stateStore, params.node);

	if (!lnsObject) {
		throw new Error('No lns object is associated with this name');
	}

	lnsObject.ttl = params.ttl ?? lnsObject.ttl;
	lnsObject.ownerAddress = params.ownerAddress ?? lnsObject.ownerAddress;
	lnsObject.expiry = params.expiry ?? lnsObject.expiry;
	lnsObject.records = params.records ?? lnsObject.records;

	lnsObject.updatedAt = Math.ceil(Date.now() / 1000);

	await stateStore.chain.set(getKeyForNode(params.node), codec.encode(lnsNodeSchema, lnsObject));
};
----

With this, all the required assets of the LNS blockchain application are implemented.
The final step is now to add them to module, which will be done in the next chapter, where the LNS module is implemented.

== Creating the LNS module

To implement the LNS module, take a look at the module skeleton:

.lns/lns_module.ts
[source,typescript]
----
import {
    BaseModule,
    AfterBlockApplyContext,
    TransactionApplyContext,
    BeforeBlockApplyContext,
    AfterGenesisBlockApplyContext,
    // GenesisConfig
} from 'lisk-sdk';

export class LnsModule extends BaseModule {
    public actions = {
        // Example below
        // getBalance: async (params) => this._dataAccess.account.get(params.address).token.balance,
        // getBlockByID: async (params) => this._dataAccess.blocks.get(params.id),
    };
    public reducers = {
        // Example below
        // getBalance: async (
		// 	params: Record<string, unknown>,
		// 	stateStore: StateStore,
		// ): Promise<bigint> => {
		// 	const { address } = params;
		// 	if (!Buffer.isBuffer(address)) {
		// 		throw new Error('Address must be a buffer');
		// 	}
		// 	const account = await stateStore.account.getOrDefault<TokenAccount>(address);
		// 	return account.token.balance;
		// },
    };
    public name = 'lns';
    public transactionAssets = [];
    public events = [
        // Example below
        // 'hello:newBlock',
    ];
    public id = 1000;

    // public constructor(genesisConfig: GenesisConfig) {
    //     super(genesisConfig);
    // }

    // Lifecycle hooks
    public async beforeBlockApply(_input: BeforeBlockApplyContext) {
        // Get any data from stateStore using block info, below is an example getting a generator
        // const generatorAddress = getAddressFromPublicKey(_input.block.header.generatorPublicKey);
		// const generator = await _input.stateStore.account.get<TokenAccount>(generatorAddress);
    }

    public async afterBlockApply(_input: AfterBlockApplyContext) {
        // Get any data from stateStore using block info, below is an example getting a generator
        // const generatorAddress = getAddressFromPublicKey(_input.block.header.generatorPublicKey);
		// const generator = await _input.stateStore.account.get<TokenAccount>(generatorAddress);
    }

    public async beforeTransactionApply(_input: TransactionApplyContext) {
        // Get any data from stateStore using transaction info, below is an example
        // const sender = await _input.stateStore.account.getOrDefault<TokenAccount>(_input.transaction.senderAddress);
    }

    public async afterTransactionApply(_input: TransactionApplyContext) {
        // Get any data from stateStore using transaction info, below is an example
        // const sender = await _input.stateStore.account.getOrDefault<TokenAccount>(_input.transaction.senderAddress);
    }

    public async afterGenesisBlockApply(_input: AfterGenesisBlockApplyContext) {
        // Get any data from genesis block, for example get all genesis accounts
        // const genesisAccounts = genesisBlock.header.asset.accounts;
    }
}
----

As you can see, the following values have been pre-filled when creating the LNS module with Lisk Commander in step <<bootstrapping-the-default-application>>.

* `name`: The module name (here: `lns`).
* `id`: The module ID (here: `1000`).

We will now implement the following parts of the skeleton:

. <<assets>>
. <<actions>>
. <<reducers>>

The events and lifecycle hooks are not required in this use case, so you can leave the skeletons as they are.

=== Assets

Now, let's add the assets we created before in step <<creating-the-lns-module-assets>>.
Import the different assets to the LNS module as shown in the snippet below.

Then, create a new instance of each asset and add them as array to the `transactionAssets` property of the LNS module.

.lns/lns_module.ts
[source,typescript]
----
import { RegisterAsset } from './assets/register';
import { UpdateRecordsAsset } from './assets/update_records';
import { ReverseLookupAsset } from './assets/reverse_lookup';

export class LnsModule extends BaseModule {
    // ...
    public transactionAssets = [
		new RegisterAsset(),
		new ReverseLookupAsset(),
		new UpdateRecordsAsset(),
	];
    // ...
}
----

That's all that is needed to add new assets to the LNS module.

=== Actions

The LNS module should have the following actions:

* `lookupAddress`: returns an LNS object based on a provided account address.
* `resolveName`: returns an LNS object based on a domain name.
* `resolveNode`: returns an LNS object based on a node hash value.

All three actions are returning an <<lns-node-schema, LNS object>>, based on different input parameters like the address it is registered to, the domain name that is registered in the LNS object, or a hash of the LNS object, which is typically stored in user account under the key `lns.ownNodes`.

The main logic of the different actions is imported from the file `storage.ts`, and is explained in detail in step <<utility-functions-3>> below.

.lns/lns_module.ts
[source,typescript]
----
import {
    BaseModule,
    codec,
    AfterBlockApplyContext,
    TransactionApplyContext,
    BeforeBlockApplyContext,
    AfterGenesisBlockApplyContext,
    // GenesisConfig
} from 'lisk-sdk';
import { RegisterAsset } from './assets/register';
import { UpdateRecordsAsset } from './assets/update_records';
import { ReverseLookupAsset } from './assets/reverse_lookup';
import { LNSNode, LNSNodeJSON, lnsNodeSchema, lsnAccountPropsSchema } from './data';
import { lookupAddress, resolveName, resolveNode } from './storage';

export class LnsModule extends BaseModule {
    public actions = {
		lookupAddress: async (params: Record<string, unknown>): Promise<LNSNodeJSON> => {
			const lnsObject = await lookupAddress({
				accountGetter: this._dataAccess.getAccountByAddress.bind(this),
				chainGetter: this._dataAccess.getChainState.bind(this),
				address: Buffer.from((params as { address: string }).address, 'hex'),
			});

			return codec.toJSON(lnsNodeSchema, lnsObject);
		},
		resolveName: async (params: Record<string, unknown>): Promise<LNSNodeJSON> => {
			const lnsObject = await resolveName({
				chainGetter: this._dataAccess.getChainState.bind(this),
				name: (params as { name: string }).name,
			});

			return codec.toJSON(lnsNodeSchema, lnsObject);
		},
		resolveNode: async (params: Record<string, unknown>): Promise<LNSNodeJSON> => {
			const lnsObject = await resolveNode({
				chainGetter: this._dataAccess.getChainState.bind(this),
				node: Buffer.from((params as { node: string }).node, 'hex'),
			});

			return codec.toJSON(lnsNodeSchema, lnsObject);
		},
	};
    // ...
}
----

=== Reducers

The methods needed in reducers are very similar to the methods in <<actions>> above.
The only difference is, that the `StateStore` is available inside of reducers, so let's use it instead of `dataAccess` to query the database:

.lns/lns_module.ts
[source,typescript]
----
import {
    BaseModule,
    codec,
    StateStore,
    AfterBlockApplyContext,
    TransactionApplyContext,
    BeforeBlockApplyContext,
    AfterGenesisBlockApplyContext,
    // GenesisConfig
} from 'lisk-sdk';
import { RegisterAsset } from './assets/register';
import { UpdateRecordsAsset } from './assets/update_records';
import { ReverseLookupAsset } from './assets/reverse_lookup';
import { LNSNode, LNSNodeJSON, lnsNodeSchema, lsnAccountPropsSchema } from './data';
import { lookupAddress, resolveName, resolveNode } from './storage';

export class LnsModule extends BaseModule {
    // ...
    public reducers = {
		lookupAddress: async (
			params: Record<string, unknown>,
			stateStore: StateStore,
		): Promise<LNSNode> =>
			lookupAddress({
				accountGetter: stateStore.account.get.bind(this),
				chainGetter: stateStore.chain.get.bind(this),
				address: (params as { address: Buffer }).address,
			}),
		resolveName: async (
			params: Record<string, unknown>,
			stateStore: StateStore,
		): Promise<LNSNode> =>
			resolveName({
				chainGetter: stateStore.chain.get.bind(this),
				name: (params as { name: string }).name,
			}),
		resolveNode: async (
			params: Record<string, unknown>,
			stateStore: StateStore,
		): Promise<LNSNode> =>
			resolveNode({
				chainGetter: stateStore.chain.get.bind(this),
				node: (params as { node: Buffer }).node,
			}),
	};
    // ...
}
----

Don't forget to add a new interface for `LNSNodeJSON` to the file `data/lns_node.ts`.

.src/app/modules/lns/data/lns_node.ts
[source,typescript]
----
// ...
export interface LNSNodeJSON {
	ownerAddress: string;
	name: string;
	ttl: number;
	expiry: number;
	records: LNSNodeRecordJSON[];
	createdAt: number;
	updatedAt: number;
}
// ...
----

=== Utility functions

Add the code of the functions `resolveNode()`, resolveName()` and `lookupAddress()` to the file `storage.ts`, to complete the implementation of the actions and reducers of the LNS module.

.src/app/modules/lns/storage.ts
[source,typescript]
----
import * as namehash from 'eth-ens-namehash';
import { chain, codec, StateStore } from 'lisk-sdk';
import { EMPTY_BUFFER, LNS_PREFIX } from './constants';
import { LNSAccountProps, LNSNode, lnsNodeSchema } from './data';
import { isExpired } from './utils';

export const getKeyForNode = (node: Buffer): string => `${LNS_PREFIX}:${node.toString('hex')}`;
export const getNodeForName = (name: string): Buffer =>
	Buffer.from(namehash.hash(name).slice(2), 'hex');

export const resolveNode = async ({
	chainGetter,
	node,
}: {
	chainGetter: (address: string) => Promise<Buffer | undefined>;
	node: Buffer;
}): Promise<LNSNode> => {
	const result = await chainGetter(getKeyForNode(node));

	if (!result) {
		throw new Error(`Node "${node.toString('hex')}" could not resolve.`);
	}

	const lnsNode = codec.decode<LNSNode>(lnsNodeSchema, result);

	if (isExpired(lnsNode)) {
		throw new Error(`Node "${node.toString('hex')}" is associated to an expired LNS object.`);
	}

	return lnsNode;
};

export const resolveName = async ({
	chainGetter,
	name,
}: {
	chainGetter: (address: string) => Promise<Buffer | undefined>;
	name: string;
}): Promise<LNSNode> => {
	const result = await chainGetter(getKeyForNode(getNodeForName(name)));

	if (!result) {
		throw new Error(`Name "${name}" could not resolve.`);
	}

	const lnsNode = codec.decode<LNSNode>(lnsNodeSchema, result);

	if (isExpired(lnsNode)) {
		throw new Error(`Name "${name}" is associated to an expired LNS object.`);
	}

	return lnsNode;
};

export const lookupAddress = async ({
	accountGetter,
	chainGetter,
	address,
}: {
	accountGetter: (address: Buffer) => Promise<chain.Account<LNSAccountProps>>;
	chainGetter: (address: string) => Promise<Buffer | undefined>;
	address: Buffer;
}): Promise<LNSNode> => {
	let account: chain.Account<LNSAccountProps>;

	try {
		account = await accountGetter(address);
	} catch {
		throw new Error(`Lookup account "${address.toString('hex')}" not found.`);
	}

	if (account.lns.reverseLookup === EMPTY_BUFFER) {
		throw new Error(`Account "${address.toString('hex')}" is not associated with any LNS object.`);
	}

	const result = await chainGetter(getKeyForNode(account.lns.reverseLookup));

	if (!result) {
		throw new Error(`Problem looking up node "${account.lns.reverseLookup.toString('hex')}"`);
	}

	const lnsNode = codec.decode<LNSNode>(lnsNodeSchema, result);

	if (isExpired(lnsNode)) {
		throw new Error(`Account "${address.toString('hex')}" is associated to an expired LNS object.`);
	}

	return lnsNode;
};

// ...
----

With this last step, all required parts of the LNS module are implemented.

=== Updating the genesis block

NOTE: In case the LNS tutorial was cloned from the `lisk-sdk-examples` repository, this step can be skipped, as the example application already contains the correct genesis block.

If the blockchain application was bootstrapped newly with `lisk init`, it still contains a default genesis block, which doesnt include the account schema of the new LNS module.
Therefore it is needed to create a new genesis block with genesis accounts that include the new account properties of the LNS module.

//TODO: Add more information about how to update the genesis block
TIP: A lot of detailed information about this process can be found in the guide xref:{url_guide_genesisblock}[].

./lisk-name-service/lns/
[source,bash]
----
./bin/run genesis-block:create --output  /home/USERNAME/.lisk/lns/config/default
----

Copy the following content to `~/.lisk/lns/config/default/config.json`:

* copy the content of `forging_info.json` to under forging.delegates
* copy the content of `password.json` to under forging.defaultPassword

Save the file `accounts.json` somewhere safe, it contains the credentials for all genesis accounts.
In the LNS example application, the file is stored in the {url_sdkexamples_lns_secret}[lisk-name-service/lns/.secret/^] folder.

After the genesis block and config are updated, the application should start again successfully. To start, run the following command:

.lisk-name-service/lns/
[source,bash]
----
./bin/run start
----

Before we go on with developing the frontend part of the LNS application, let's quickly check if the blockchain application is working as expected by enabling the Dashboard plugin in the next chapter.

== Connecting the Dashboard and Faucet plugins

The Dashboard plugin provides a web interface that allows developers to interact with their blockchain application during development.

The Faucet plugin provides a web interface with a faucet, allowing account in the network to receive free tokens conveniently.

By enabling the Dashboard and Faucet plugins in the blockchain application, we are able to test the functionality of the application by interacting with it through the browser.

Among other things, it will be possible to ...

* ... create new accounts with the Dashboard
* ... fund accounts with tokens via the Faucet
* ... send transactions to the LNS application to ...
** ... register new domain names.
** ... set the domain name for a reverse lookup.
** ... update the records of a domain name.
* ... call actions on the LNS application to ...
** ... perform a reverse lookup for an account address.
** ... return an LNS object based on the domain name.
** ... return an LNS object based on the LNS object hash.
** ... perform a reverse lookup for an account address.

Before the Dashboard and Faucet plugins can be used for this purpose, it is first needed to install them and to register them with the LNS application, which is done in the next step.

[NOTE]
====
More information about the Dashboard plugin can be found in the development guide xref:{url_guide_dashboard}[] or on the reference page of the xref:{url_reference_dashboard}[].

More information about the Faucet plugin can be found on the reference page of the xref:{url_reference_faucet}[].
====

=== Registering the Dashboard plugin

Install the dashboard plugin:

.lisk-name-service/
[source,bash]
----
npm i @liskhq/lisk-framework-dashboard-plugin
----

Now open `plugins.ts`, import the Dashboard plugin, and register it with the application as shown below:

.lisk-name-service/lns/src/app/plugins.ts
[source,typescript]
----
import { Application } from 'lisk-sdk';
import { DashboardPlugin } from "@liskhq/lisk-framework-dashboard-plugin";

export const registerPlugins = (app: Application): void => {

    app.registerPlugin(DashboardPlugin);
};
----

Save and close `plugins.ts`.

=== Registering the Faucet plugin

[TIP]

You can skip this step, if you don't create a new account in step <<create-new-account>>, but rather use on of the existing genesis accounts.
Genesis accounts normally have an initial amount of tokens in their balance, so in this case, it is not needed for them to receive funds via the faucet.

Install the faucet plugin:

.lisk-name-service/
[source,bash]
----
npm i @liskhq/lisk-framework-dashboard-plugin
----

Now open `plugins.ts`, import the Dashboard plugin, and register it with the application as shown below:

.lisk-name-service/lns/src/app/plugins.ts
[source,typescript]
----
import { Application } from 'lisk-sdk';
import { DashboardPlugin } from "@liskhq/lisk-framework-dashboard-plugin";
import { FaucetPlugin } from "@liskhq/lisk-framework-faucet-plugin";

export const registerPlugins = (app: Application): void => {

    app.registerPlugin(DashboardPlugin);
    app.registerPlugin(FaucetPlugin);
};
----

Save and close `plugins.ts`.

Choose one of the genesis delegate to be the faucet account, e.g. the first account in `lisk-name-service/.secret/accounts.json`.

.lisk-name-service/.secret/accounts.json
[source,js]
----
[
	{
		"passphrase": "brush swamp sign omit cabin review menu tent spend shy plug strategy",
		"address": "49e8b0411cd96a17a72f88dfe802179b4113924f"
	},
	// ...
]
----

Use Lisk Commander to encrypt the passphrase of the account with a password.
Save the password somewhere, it is needed to enable and disable the faucet later.

[source,bash]
----
$ lisk passphrase:encrypt
? Please enter passphrase:  [hidden]
? Please re-enter passphrase:  [hidden]
? Please enter password:  [hidden] # <1>
? Please re-enter password:  [hidden]
{"encryptedPassphrase":"iterations=1000000&cipherText=643bfbf1b6f1dc0ce740dd9fc9f27a682e476dc5de4e6c023deded4d3efe2822346226541106b42638db5ba46e0ae0a338cb78fb40bce67fdec7abbca68e20624fa6b0d7&iv=8a9c461744b9e70a8ba65edd&salt=3fe00b03d10b7002841857c1f028196e&tag=c57a798ef65f5a7be617d8737828fd58&version=1"}
----

<1> Choose a simple password to encrypt the passphrase symmetrically.
The password will be needed later to enable the faucet plugin through the action `faucet:authorize`.

Open the config file of the LNS application which is located under the path `~/.lisk/lns/config/default/config.json` and scroll down to the bottom of the file.
Add the required configuration options for the faucet plugin under the key `plugins.faucet`:

* `encryptedPassphrase`: The encrypted passphrase of the account that will provide the tokens for the faucet.
* `captchaSecretkey`: The secret API key for the captcha.
* `captchaSitekey`: The API site key for the captcha.

The {url_recaptcha_keys}[free site key and secret key for reCAPTCHA^] are used below for testing purposes.

.~/.lisk/lns/config/default/config.json
[source,json]
----
"plugins": {
    "faucet": {
        "encryptedPassphrase": "iterations=1000000&cipherText=643bfbf1b6f1dc0ce740dd9fc9f27a682e476dc5de4e6c023deded4d3efe2822346226541106b42638db5ba46e0ae0a338cb78fb40bce67fdec7abbca68e20624fa6b0d7&iv=8a9c461744b9e70a8ba65edd&salt=3fe00b03d10b7002841857c1f028196e&tag=c57a798ef65f5a7be617d8737828fd58&version=1",
        "captchaSecretkey": "6LeIxAcTAAAAAGG-vFI1TnRWxMZNFuojJ4WifJWe",
        "captchaSitekey": "6LeIxAcTAAAAAJcZVRqyHh71UMIEGNQ_MXjiZKhI"
    }
}
----

The last step to use the Faucet plugin is to enable it via the action `faucet:authorize`.
This can be achieved with the Dashboard plugin.

Start the blockchain application again:

[source,bash]
----
./bin/run start
----

Wait until the application start is completed.

Go to {url_dashboard} to access the dashboard.

Now go to the `Call actions` section on the Dashboard, and select the action `faucet:authorize`.

image:tutorials/lns/faucet-authorize-action.png[faucet:authorize,200,100]

The actions expects as input a boolean, if the plugin should be enabled, and a password the decrypt the encrypted passphrase that was saved in `config.json` above.

Add the following JSON object to the field for the asset data:

[source,json]
----
{
    "enable": true,
    "password": "myPassword" // <1>
}
----

<1> Change this to the password you used above to encrypt the passphrase in the Faucet plugin configuration.

Hit the kbd:[Submit] button to invoke the action.
You should see a confirmation that the action was invoked successfully.

image:tutorials/lns/faucet-authorize-success.png[faucet:authorize-success,200,100]

It is now possible to use the faucet under {url_faucet} .

image:tutorials/lns/faucet.png[Faucet,400,200]

=== Checking the functionality of the LNS module

Now let's go to the dashboard under {url_dashboard} .

image:tutorials/lns/dashboard.png[Dashboard,400,200]

[CAUTION]

The Dashboard is only storing data for the current browser session.
Reloading the page will delete all temporary data in the accounts, block and transaction logs of the Dashboard.

==== Create new account

Click on the button kbd:[Generate new account] in the top right corner of the page to create a new account:

image:tutorials/lns/new-account.png[new-account,200,100]

The new account will also appear in the `My Accounts` section.
Clicking on the account will open again the above window with the account credentials.

==== Fund new account

Before it is possible to send any transactions, it is first needed to receive a certain amount of tokens to the new account.
The tokens will be used to pay the transaction fees for the different transaction we are going to send.

Copy the Lisk32 address of the newly created account, go to the Faucet page, and receive tokens by pasting the address, checking the captcha, and hitting kbd:[Request].

image:tutorials/lns/faucet-send.png[faucet-send,200,100]

If the tokens were transferred successfully, you will see the following confirmation message:

image:tutorials/lns/faucet-fund-success.png[faucet-fund-success,200,100]

Back on the Dashboard, it is possible to see the transfer transaction from the Faucet in the transactions log:

image:tutorials/lns/transactions1.png[transactions1,200,100]

==== Register new domain

Let's use the new account to register a domain name to it, which will be used as human-readable identifier for this account.

Scroll down to the `Send transaction` section and select `lns:register` from the dropdown menu.

image:tutorials/lns/send-tx-lns-register-dropdown.png[send-tx-lns-register-dropdown,200,100]

Paste the passphrase of the newly created account, and add the <<schema,required asset data>> for the `lns:register` transaction.

image:tutorials/lns/send-tx-lns-register.png[send-tx-lns-register,200,100]

Hit the kbd:[Submit] button to post the transaction.
If the transaction was transferred successfully, the following confirmation message will show up:

image:tutorials/lns/send-tx-lns-register-success.png[send-tx-lns-register-success,200,100]

==== Call the actions resolveName and resolveNode

Once the `lns:register` transaction is applied, (which should be the case after ~10 seconds), a new LNS object for the domain name should be created, and a hash of this object should be added to the senders account.

This new LNS object can be queried by invoking the two actions `lns:resolveName` and `lns:resolveNode` which we defined before in section <<actions>>.
Go to the section `Call action` on the dashboard and select `lns:resolveName` from the dropdown menu.
Provide the expected input for the action in the field below.

image:tutorials/lns/call-action-lns-resolvename.png[call-action-lns-resolvename,200,100]

This should return the corresponding LNS object, which was just created by registering the domain name in the step before:

image:tutorials/lns/call-action-lns-resolvename-success.png[call-action-lns-resolvename-success,200,100]

Now select `lns:resolveNode` from the dropdown menu.
Provide the expected input for the action in the field below.

image:tutorials/lns/call-action-lns-resolvenode.png[call-action-lns-resolvenode,200,100]

If this returns the same result as `lns:resolveName`, it is verified that both actions work as expected.

==== Define a reverse lookup address

Let's now add the newly created domain name as reverse lookup address for our account.

This will tell the LNS app to which domain name the address should resolve to by default.
This is important, because a single account can register many different domain names at once.

In the `Send transaction` section, select `lns:reverse-lookup` from the dropdown menu.

image:tutorials/lns/send-tx-lns-reverselookup-dropdown.png[lns-reverselookup-dropdown,200,100]

Paste the passphrase of the account like before, and add the <<schema-2,required asset data>> for the `lns:reverse-lookup` transaction.

image:tutorials/lns/send-tx-lns-reverselookup.png[lns-reverselookup,200,100]

Hit the kbd:[Submit] button to post the transaction.
If the transaction was transferred successfully, the following confirmation message will show up:

image:tutorials/lns/send-tx-lns-reverselookup-success.png[lns-reverselookup-success,200,100]

In the section `Recent Transactions` on the dashboard, it is possible to see an overview about all sent transactions so far:

image:tutorials/lns/transactions2.png[transactions2,200,100]

==== Update the records for a domain name

Now, last but not least, test the `lns:update-records` transaction, which allows a user to update the records of a registered domain name.
At the beginning, there are no existing records yet, so let's create a first one:

Again, paste the passphrase of the account like before, and add the <<schema-3,required asset data>> for the `lns:update-records` transaction.

image:tutorials/lns/send-tx-lns-update-records.png[lns-update-records,200,100]

Hit the kbd:[Submit] button to post the transaction.
If the transaction was transferred successfully, the following confirmation message will show up:

image:tutorials/lns/send-tx-lns-update-records-success.png[lns-update-records-success,200,100]

In the section `Recent Transactions` on the dashboard, the overview about all sent transactions now looks like this:

image:tutorials/lns/transactions3.png[transactions3,200,100]

==== Check account details

With the action `app:getAccount`, it is possible to get the data of an account based on its' address.

Please be aware that the action expects the account address in hexadecimal representation (not Lisk32), like shown in the example below.

image:tutorials/lns/call-action-app-getaccount.png[call-action-app-getaccount,200,100]

As a result, we receive an object which contains all the account data.
The data for the `lns` module is added at the bottom.
The domain name hash is already added to the property `lns.ownNodes`, and the `lns.reverseLookup` property also points to this LNS object.

image:tutorials/lns/call-action-app-getaccount-success.png[call-action-app-getaccount-success,200,100]

==== Perform a reverse lookup for an address

Finally, let's check if the reverse lookup of the account address is working as expected.
In the section `Call action`, select `lns:lookupAddress` from the dropdown menu and provide the address in the input field, again, the address needs to be in hexadecimal representation.

image:tutorials/lns/call-action-lns-lookupaddress.png[lns-lookupaddress,200,100]

The reverse lookup was successful, if the expected LNS object is returned.

image:tutorials/lns/call-action-lns-resolvenode-success.png[lns-lookupaddress-success,200,100]

All important features of the LNS blockchain application have now been successfully tested with help of the Dashboard plugin.

== Using a plugin as frontend

The dashboard plugin is nice to use during development of th blockchain application, because it offers a simple way to interact with the blockchain application through a user interface.
To make it more convenient for normal users to use the application, add a frontend to the application which is specialized on the respective use case of the LNS applicationn.

For the LNS app, we want to provide a simple *frontend as a plugin*, which is registered to the LNS blockchain application.
See the xref:{url_bapps_frontend}[Frontend & Backend] section for more information about the different possibilities to provide a frontend for a blockchain application.

A simple React.js web application is used as frontend.
The development of the React application is not covered in this tutorial in detail.
Instead, we will use the existing React frontend in the `lisk-sdk-examples` repository: {url_sdkexamples_lns_uiplugin}[^] and see how it can be included as a standalone UI plugin for a blockchain application.

TIP: If you want to learn more about how to develop a React frontend application, check out the {url_reactjs_docs}[React.js documentation^].


=== The React frontend application
//TODO: Too complicated, just refer to already existing UI and how to clone it

.lisk-name-service/
[source,bash]
----
cd .. # <1>
git clone https://github.com/LiskHQ/lisk-sdk-examples.git # <2>
cp -R lisk-sdk-examples/tutorials/lisk-name-service/lns-dashboard-plugin lisk-name-service/lns-dashboard-plugin # <3>
----

<1> Move out of the `lisk-name-service` folder.
<2> Clone the `lisk-sdk-examples` repository.
<3> Copy the LNS Dashboard plugin to the root folder of your LNS blockchain application.

As you might notice when looking at the files, the LNS Dashboard plugin is based on the code of the {url_sdk_dashboardplugin}[Dashboard plugin^] from the Lisk SDK Framework.

The file structure of the UI plugin is basically a merge of a React.js application and a Lisk plugin.
The main logic of the React application is located under `lns-dashboard-plugin/src/ui/`, and the main logic fie the LNS UI Plugin is located in `lns-dashboard-plugin/src/app/`.

////

How to create a React app with {url_reactjs}[create-react-app^]

.lisk-name-service/lns-ui/
[source,bash]
----
npx create-react-app ui
----
////

.Creating a standalone UI plugin
****
There is no need to generate any files newly, as we simplified the process by downloading the prepared frontend plugin for the LNS blockchain application.
But in case you want to create your own standalone plugin from scratch, you can use Lisk Commander to generate a plugin skeleton, just like it was done when generating the <<bootstrapping-the-default-application, Modules>> and <<assets>> skeletons:

.lisk-name-service/
[source,bash]
----
$ lisk generate:plugin --standalone lnsui
Using template "lisk-ts"
Initializing git repository
Updating .liskrc.json file
Creating plugin project structure
? Author of plugin mona
? Version of plugin 0.1.0
? Name of plugin lnsui
? Description of plugin A plugin for an application created by Lisk SDK
? License of plugin ISC
----
****

=== Adding the plugin to the LNS blockchain application

Open the `package.json` file and add the downloaded LNS Dashboard plugin to the dependencies:

.lisk-name-service/lns/package.json
[source,json]
----
{
  // ...
  "dependencies": {
    "lns-dashboard-plugin": "file:../lns-dashboard-plugin"
  // ...
}
----

Now open `plugins.ts`, import the UI plugin, and register it with the application as shown below:

.lisk-name-service/lns/src/app/plugins.ts
[source,typescript]
----
import { Application } from 'lisk-sdk';
import { DashboardPlugin } from "@liskhq/lisk-framework-dashboard-plugin";
import { FaucetPlugin } from "@liskhq/lisk-framework-faucet-plugin";
import { LNSDashboardPlugin } from 'lns-dashboard-plugin';

export const registerPlugins = (app: Application): void => {
    app.registerPlugin(DashboardPlugin);
    app.registerPlugin(FaucetPlugin);
	app.registerPlugin(LNSDashboardPlugin);

	app.overridePluginOptions(LNSDashboardPlugin.alias, {
		applicationUrl: `ws://localhost:${app.config.rpc.port}/ws`,
		port: 8000,
	});
};
----

Save and close `plugins.ts`.
Restart the LNS blockchain application to apply the changes.

.lisk-name-service/lns/
[source,bash]
----
./bin/run start
----

After the application has loaded, it is possible to acceess the LNS Dashboard under http://localhost:8000.

image:tutorials/lns/ui-disconnected.png[UI disconnected,200,100]

Use the credentials of the account that was created newly in the previous step <<create-new-account>> to connect to the LNS frontend.

image:tutorials/lns/ui-connected.png[UI connected,200,100]

At the top right corner you will now see the domain that was defined as <<define-a-reverse-lookup-address,reverse lookup>> for the account address.
If you tick of the slider `Enable LNS`, the address of the account will be displayed again, instead of the domain name.

By clicking on your account you will reach the following page, giving all important information about your account and the domain names that are registered for this account.
Currently, one domain name is registered to the account.
This was done in step <<register-domain>> via the Dashboard plugin.

You can also see the new TXT record that was added to the LNS object.

image:tutorials/lns/ui-account-page.png[UI account page,200,100]

Go back to the index page of the LNS Dashboard and search for a new domain name to add to your account.

The LNS Dashboard will automatically check its' availability.
If no other user has registered tis domain at the moment, it will provide a link to a dialog to register the new domain.

In the screenshot, we search for the domain `awesome.lsk`, and luckily, it isn't taken, yet.

image:tutorials/lns/ui-search-results.png[UI search results,200,100]

Click on the `Register` link to open the dialog to register the domain.

The minimum fee of the Register transaction is calculated automatically, after all required transaction data is pasted in the fields.
Please make sure to always use at least the minimum fee for the transaction, or it will bee rejected by the blockchain application.

Hit kbd:[Register] to send the domain name registration to the LNS blockchain application.

Wait for confirmation of the LNS app to have received your transaction.

image:tutorials/lns/ui-register-dialog.png[UI register dialog,200,100]
image:tutorials/lns/ui-confirmation.png[UI confirmation,200,100]

Now go back to your account page.
You should see the new domain name listed there.

image:tutorials/lns/ui-account2.png[UI account page 2,200,100]
image:tutorials/lns/ui-account-awesome-details.png[UI domain details,200,100]

Unfortunately, on the top right, our address is still resolving to the `my-name.lsk` domain (if LNS is enabled).
So let's update the reverse lookup of the account to point to the new domain name `awesome.lsk`.

Open the Dialog for updating the reverse lookup by clicking on kbd:[Update reverse lookup] in the top right.

image:tutorials/lns/ui-reverse-lookup-dialog.png[UI reverse lookup dialog,200,100]

Choose `awesome.lsk` fromt he dropdown menu, enter the account passphrase and the minimum fee.

Click kbd:[Update] to update the reverse lookup entry for this account.
As a result, you can verify that the LNS Dashboard now resolves the account address automatically to the new domain name `awesome.lsk`.

image:tutorials/lns/ui-updated.png[UI updated name,200,100]

Try to search again for the domain name `awesome.lsk`.
The search results should now inform you that this domain name is already reserved.

image:tutorials/lns/ui-reach-reserved.png[UI search for reserved name,200,100]

Play around as much as you like with the LNS application UI.

The development of frontend and backend of the LNS application is now complete, and the application has all the features that were described in chapter <<lns-application-overview>> at the top.

In the next chapter, the LNS application CLI will be enhanced with commands specific to the LNS module.
This allows to interact with the blockchain application directly via the command-line, which can be beneficial for developers and/or node operators.

== Extending the application CLI

To further enhance the LNS blockchain application, let's create two new LNS specific commands, which can be exeecuted directly from the command line:

* <<lnsresolve>> Command to resolve a provided domain name to an account address.
* <<lnslookup>>: Command to perform a reverse lookup for a provided account address.
Returns the default domain name of an account.

The application CLI already contains a lot of general commands by default.
They are directly created when the application isa bootstrapped with Lisk Commander with `lisk init`.

You can see an overview of all existing CLI commands by navigating to the root folder of the blockchain application, and running

[source,bash]
----
./bin/run
----

This will return the command reference for the application CLI:

----
Lisk-SDK Application

VERSION
  lns/0.1.0 darwin-x64 node-v12.22.3

USAGE
  $ lisk-name-service [COMMAND]

TOPICS
  account        Commands relating to lisk-name-service accounts.
  block          Commands relating to lisk-name-service blocks.
  blockchain     Commands relating to lisk-name-service blockchain data.
  config         Commands relating to lisk-name-service node configuration.
  forger-info    Commands relating to lisk-name-service forger-info data.
  forging        Commands relating to lisk-name-service forging.
  genesis-block  Creates genesis block file.
  node           Commands relating to lisk-name-service node.
  passphrase     Commands relating to lisk-name-service passphrases.
  transaction    Commands relating to lisk-name-service transactions.

COMMANDS
  autocomplete  display autocomplete installation instructions
  console       Lisk interactive REPL session to run commands.
  hash-onion    Create hash onions to be used by the forger.
  help          display help for lisk-name-service
  start         Start Blockchain Node.
----

We already used the CLI in this tutorial to start the LNS application.
Now, the plan is to create a new topic `lns`, and to define the two new commands `lns:resolve` and `lns:lookup` to be part of it.

Navigate to `lisk-name-service/lns/commands/` and create a new folder `lns`, which will contain the files for the new commands.

.lisk-name-service/lns/commands/
[source,bash]
----
mkdir lns
cd lns
----

[TIP]

====
The application CLI commands are based on {url_oclif}[oclif^].

Check out their documentation to get a deeper understanding on how the CLI commands are constructed.
====

=== lns:resolve

Create a new file `resolve.ts` and import the `BaseIPCClientCommand` from Lisk Commander.

Create a new class `LNSResolveCommand`, which extends the class {url_sdk_baseipcclient}[BaseIPCClientCommand^] of Lisk Commander.

./lisk-name-service/lns/src/commands/lns/resolve.ts
[source,typescript]
----
import { BaseIPCClientCommand } from 'lisk-commander';

export class LNSResolveCommand extends BaseIPCClientCommand {

}
----

The `BaseIPCClientCommand` already contains two optional default flags for the command: `pretty` and `data-path`.
It also contains an API client to the node which we will use to invoke actions in the LNS application via the CLI.

The only method required for a new command is the `.run()` function.

In this particular use case, we also need one argument, the name to resolve.

You may also add some examples about the usage of the command, which will be added to the auto-generated command reference.

./lisk-name-service/lns/src/commands/lns/resolve.ts
[source,typescript]
----
import { BaseIPCClientCommand } from 'lisk-commander';

export class LNSResolveCommand extends BaseIPCClientCommand {
    // Available command arguments
	static args = [
		{
			name: 'name',
			required: true,
			description: 'Name to resolve.',
		},
	];

	// Command usage examples
	static examples = ['lns:resolve jhon.lsk', 'lns:resolve jhon.lsk --pretty'];

	// Executed every time the respective command is executed in the CLI.
	public async run(): Promise<void> {
	    // Parses the provided command arguments
		const { args } = this.parse(LNSResolveCommand);
		// Get the name argument from the arguments object
		const { name } = args as { name: string };

		// Invoke the action 'lns:resolveName' on the node via the API client.
		const result = await this._client?.invoke('lns:resolveName', { name });

		// If the node returns a result, print it to the console as JSON.
		if (result) {
			return this.printJSON(result);
		}

		// Display this message, if the name couldn't be resolved successfully.
		return this.log(`Can not resolve name "${name}"`);
	}
}
----

This is all code needed to add the new command to the LNS blockchain application.

As you see, there is not much logic needed to implement.
We can reuse the action <<actions,lns:resolveName>> to get the address, based on the address that was provided as command argument.

=== lns:lookup

Create a new file `lookup.ts` and paste the code snippet below.
This is all code needed to add the `lns:lookup` command to the LNS blockchain application.

The implementation is analog to the previous command, but now use the corresponding action `lns:lookup` to get the domain name for the provided account address.

./lisk-name-service/lns/src/commands/lns/lookup.ts
[source,typescript]
----
import { BaseIPCClientCommand } from 'lisk-commander';

export class LNSLookupCommand extends BaseIPCClientCommand {
	static args = [
		{
			name: 'address',
			required: true,
			description: 'Address to lookup',
		},
	];

	static examples = ['lns:lookup <hex-address>', 'lns:lookup afe179fa12a988c1244444479c --pretty'];

	public async run(): Promise<void> {
		const { args } = this.parse(LNSLookupCommand);
		const { address } = args as { address: string };

		if (address !== Buffer.from(address, 'hex').toString('hex')) {
			this.error('Invalid address format');
		}

		const result = await this._client?.invoke('lns:lookupAddress', { address });

		if (result) {
			return this.printJSON(result);
		}

		return this.log(`Can not find account with address "${address}"`);
	}
}
----

=== Trying out the new CLI commands

Display the CLI reference once again.
The new topic `lns` should now show up under `TOPICS`:

[source,bash]
----
./bin/run
----

----
Lisk-SDK Application

VERSION
  lns/0.1.0 darwin-x64 node-v12.22.3

USAGE
  $ lisk-name-service [COMMAND]

TOPICS
  account        Commands relating to lisk-name-service accounts.
  block          Commands relating to lisk-name-service blocks.
  blockchain     Commands relating to lisk-name-service blockchain data.
  config         Commands relating to lisk-name-service node configuration.
  forger-info    Commands relating to lisk-name-service forger-info data.
  forging        Commands relating to lisk-name-service forging.
  genesis-block  Creates genesis block file.
  lns
  node           Commands relating to lisk-name-service node.
  passphrase     Commands relating to lisk-name-service passphrases.
  transaction    Commands relating to lisk-name-service transactions.

COMMANDS
  autocomplete  display autocomplete installation instructions
  console       Lisk interactive REPL session to run commands.
  hash-onion    Create hash onions to be used by the forger.
  help          display help for lisk-name-service
  start         Start Blockchain Node.
----

If the LNS application os not already running, start it again:

[source,bash]
----
$ ./bin/run start
----

Now resolve the domain name `my-name.lsk`, which we registered before.

[source,bash]
----
./bin/run lns:resolve my-name.lsk
----

This will return the corresponding LNS object:

[source,json]
----
{
  "ownerAddress":"39cdb96af23eaf431ef3fb8e5da58d9950c3bc96",
  "name":"my-name.lsk",
  "ttl":4000,
  "expiry":1694173170,
  "createdAt":1631101170,
  "updatedAt":1631105400,
  "records":[{
    "type":2,
    "label":"my-twitter",
    "value":"@followMe"
  }]
}
----

When the resolve command works as expected, copy the `ownerAdress` from the returned LNS object and provide it as argument for the `lns:lookup` command:

[source,bash]
----
$ ./bin/run lns:lookup 39cdb96af23eaf431ef3fb8e5da58d9950c3bc96
----

This will return the corresponding LNS object:

[source,json]
----
{
  "ownerAddress":"39cdb96af23eaf431ef3fb8e5da58d9950c3bc96",
  "name":"awesome.lsk",
  "ttl":3600,
  "expiry":1662734230,
  "createdAt":1631198230,
  "updatedAt":1631198230,
  "records":[]
}
----

[NOTE]

====
Each account can register multiple domain names to their account.
The address lookup returns a different object for the provided address, because the account has set `awesome.lsk` to be the default domain name for this account.
====

How to display the topic reference:

[source,bash]
----
./bin/run lns
----

----
USAGE
  $ lisk-name-service lns:COMMAND

COMMANDS
  lns:lookup
  lns:resolve
----

How to display the command reference:

[source,bash]
----
$ ./bin/run lns:resolve --help
----

----
USAGE
  $ lisk-name-service lns:resolve NAME

ARGUMENTS
  NAME  Name to resolve.

OPTIONS
  -d, --data-path=data-path  Directory path to specify where node data is stored. Environment variable "LISK_DATA_PATH" can also be
                             used.

  --pretty                   Prints JSON in pretty format rather than condensed.

EXAMPLES
  lns:resolve jhon.lisk
  lns:resolve jhon.lisk --pretty
----

== Writing unit tests

As last topic of this tutorial, we'll explore how the application can be tested with unit and network tests.

Writing tests for the application gets more and more important, the more complex the blockchain application gets.
Once it reaches a certain complexity, it won't be convenient anymore to test the application functionality with the dashboard plugin, the CLI or via a frontend, and writing tests becomes a crucial part to verify the correct behavior of the blockchain application.

For this purpose, we will first add a couple of unit tests to the application in this chapter, and then a couple of network tests in the next chapter.

To make the creation of tests convenient, we will make use of xref:{url_reference_testsuite}[].

Navigate into the `test/` folder of the LNS application.
The `test` folder is the place to store all the kind of different tests for th blockchain application.

The unit tests are stored in the `test/unit/` folder, as the name suggests.

.lisk-name-service/lns/test/
----
.
├── _setup.js
├── commands
├── integration
├── network
├── tsconfig.json
├── unit
│   └── modules
│       └── lns
│           ├── assets
│           │   ├── register.spec.ts
│           │   └── reverse_lookup.spec.ts
│           └── lns.spec.ts
└── utils
----

As you can see, there are already some existing test files for the lns module and the assets.
These files were auto-generated by Lisk Commander, when the LNS module and the assets were generated.

The existing test files already contain test skeletons, providing a rough structure how to write the required tests.

=== Testing the Register asset

The complete code of the tests for the Register asset is described below.
Most of the code is self-explanatory, but the most important parts of the tests are summarized here for a better overview:

==== Testing the validate() function

Tests for the <<validation,validate() function>> of the Register asset.

Write tests to check the following:

* It should not be possible to set the TTL in the asset to a value lower than 3600 seconds (1 hour).
* It should throw error if name is registered for less than a year.
* It should throw error if name is registered for more than 5 years
* It should throw error if domain contains invalid tld.
* It not throw any error, if all asset parameters are valid.

Before each test:

* Create a new instance of the Register asset.

Use of the SDK testing utilities:

* `testing.createValidateAssetContext()`: Returns valid parameters for the `validate()` function.
If the function is called with an empty object, it xref:{url_test_suite_createvalidatecontext}[returns the default parameters] for the `validate()` function.
For the test, overwrite the default `asset` value (`undefined`) with a valid transaction asset for the Register asset.
For the function to be called successfully, overwrite the default transaction value of the context (`undefined`) with a transaction containing a property `senderAddress` with a Buffer of size 0.
No need to put a real address here in this case, as it isn't used in the tests.

==== Testing the apply() function

Tests for the <<state-change,apply() function>> of the Register asset.

Write tests to check the following:

* Valid cases:
** It should update the state store with the name hash key.
** It should update the state store with updated sender account.
** It should update the state store with correct ttl value.
** It should update the state store with correct expiry date.
* Invalid cases:
** It should throw error if name is already registered.

Before each test:

* Create a new default account for the LNS application.
* Add the newly created account to the `accounts` list of the `StateStore` mock.
* Spy on the functions `stateStore.chain.get` and `stateStore.chain.set`.
This allows to check in the tests, if the respective functions have been called or not.

Use of the SDK testing utilities:

* testing.createApplyAssetContext(): Returns valid parameters for the `apply()` function.
If the function is called with an empty object, it xref:{url_test_suite_createapplycontext}[returns the default parameters] for the `apply()` function.
For the test, overwrite the default `asset` value (`undefined`) with a valid transaction asset for the Register asset.
Additionally, overwrite the default transaction value of the context (`undefined`) with a transaction containing a property `senderAddress` which equals the address of the newly created account.
* testing.fixtures.createDefaultAccount<LNSAccountProps>([LnsModule]):
Used to create a default account for the LNS application.
* new testing.mocks.StateStoreMock({accounts: [account]}):
Creates a mock for the StateStore.

==== Unit tests for the Register asset

.lisk-name-service/lns/test/unit/modules/lns/assets/register.ts
[source,typescript]
----
import { addYears } from 'date-fns';
import { StateStore, testing } from 'lisk-sdk';
import { RegisterAsset } from '../../../../../src/app/modules/lns/assets/register';
import { LNSAccountProps } from '../../../../../src/app/modules/lns/data';
import { LnsModule } from '../../../../../src/app/modules/lns/lns_module';
import {
	getKeyForNode,
	getLNSObject,
	getNodeForName,
} from '../../../../../src/app/modules/lns/storage';

// Tests for the Register asset
describe('RegisterAsset', () => {
	let transactionAsset: RegisterAsset;

	beforeEach(() => {
		transactionAsset = new RegisterAsset();
	});

	// Tests for the constructor of the Register asset
	describe('constructor', () => {
	    // Verify that the asset ID is equal to 1.
		it('should have valid id', () => {
			expect(transactionAsset.id).toEqual(1);
		});

		// Verify that the asset name equals `'register'`
		it('should have valid name', () => {
			expect(transactionAsset.name).toEqual('register');
		});

		// Verify that the correct asset schema is used
		it('should have valid schema', () => {
			expect(transactionAsset.schema).toMatchSnapshot();
		});
	});

	describe('validate', () => {
		describe('schema validation', () => {

			it('should throw error if ttl is set less than an hour', () => {
				const context = testing.createValidateAssetContext({
					asset: { name: 'nazar.hussain', ttl: 60 * 60 - 1, registerFor: 1 },
					transaction: { senderAddress: Buffer.alloc(0) } as any,
				});

				expect(() => transactionAsset.validate(context)).toThrow(
					'Must set TTL value larger or equal to 3600',
				);
			});

			it('should throw error if name is registered for less than a year', () => {
				const context = testing.createValidateAssetContext({
					asset: { name: 'nazar.hussain', ttl: 60 * 60, registerFor: 0 },
					transaction: { senderAddress: Buffer.alloc(0) } as any,
				});

				expect(() => transactionAsset.validate(context)).toThrow(
					'You can register name at least for 1 year.',
				);
			});

			it('should throw error if name is registered for more than 5 years', () => {
				const context = testing.createValidateAssetContext({
					asset: { name: 'nazar.hussain', ttl: 60 * 60, registerFor: 6 },
					transaction: { senderAddress: Buffer.alloc(0) } as any,
				});

				expect(() => transactionAsset.validate(context)).toThrow(
					'You can register name maximum for 5 year.',
				);
			});

			it('should throw error if domain contains invalid tld', () => {
				const context = testing.createValidateAssetContext({
					asset: { name: 'nazar.hussain', ttl: 60 * 60, registerFor: 1 },
					transaction: { senderAddress: Buffer.alloc(0) } as any,
				});

				expect(() => transactionAsset.validate(context)).toThrow(
					'Invalid TLD found "hussain". Valid TLDs are "lsk"',
				);
			});

			it('should be ok for valid schema', () => {
				const context = testing.createValidateAssetContext({
					asset: { name: 'nazar.lsk', ttl: 60 * 60, registerFor: 1 },
					transaction: { senderAddress: Buffer.alloc(0) } as any,
				});

				expect(() => transactionAsset.validate(context)).not.toThrow();
			});
		});
	});

	describe('apply', () => {
		let stateStore: StateStore;
		let account: any;

		beforeEach(() => {
			account = testing.fixtures.createDefaultAccount<LNSAccountProps>([LnsModule]);

			stateStore = new testing.mocks.StateStoreMock({
				accounts: [account],
			});

			jest.spyOn(stateStore.chain, 'get');
			jest.spyOn(stateStore.chain, 'set');
		});

		describe('valid cases', () => {
			it('should update the state store with nameahsh key', async () => {
				const name = 'nazar.lsk';
				const node = getNodeForName(name);
				const key = getKeyForNode(node);
				const context = testing.createApplyAssetContext({
					stateStore,
					asset: { name: 'nazar.lsk', ttl: 60 * 60, registerFor: 1 },
					transaction: { senderAddress: account.address } as any,
				});

				await transactionAsset.apply(context);

				expect(stateStore.chain.set).toHaveBeenCalledWith(key, expect.any(Buffer));
			});

			it('should update the state store with updated sender account', async () => {
				const name = 'nazar.lsk';
				const node = getNodeForName(name);
				const context = testing.createApplyAssetContext({
					stateStore,
					asset: { name: 'nazar.lsk', ttl: 60 * 60, registerFor: 1 },
					transaction: { senderAddress: account.address } as any,
				});
				await transactionAsset.apply(context);

				const updatedSender = await stateStore.account.get<LNSAccountProps>(account.address);

				expect(updatedSender.lns.ownNodes).toEqual([node]);
			});

			it('should update the state store with correct ttl value', async () => {
				const name = 'nazar.lsk';
				const node = getNodeForName(name);
				const context = testing.createApplyAssetContext({
					stateStore,
					asset: { name: 'nazar.lsk', ttl: 60 * 70, registerFor: 1 },
					transaction: { senderAddress: account.address } as any,
				});
				await transactionAsset.apply(context);

				const lsnObject = await getLNSObject(stateStore, node);

				expect(lsnObject?.ttl).toEqual(60 * 70);
			});

			it('should update the state store with correct expiry date', async () => {
				const name = 'nazar.lsk';
				const node = getNodeForName(name);
				const context = testing.createApplyAssetContext({
					stateStore,
					asset: { name: 'nazar.lsk', ttl: 60 * 70, registerFor: 2 },
					transaction: { senderAddress: account.address } as any,
				});
				const expiryTimestamp = Math.ceil(addYears(new Date(), 2).getTime() / 1000);

				await transactionAsset.apply(context);

				const lsnObject = await getLNSObject(stateStore, node);

				expect(lsnObject?.expiry).toBeGreaterThanOrEqual(expiryTimestamp);
			});
		});

		describe('invalid cases', () => {
			it('should throw error if name is already registered', async () => {
				const context = testing.createApplyAssetContext({
					stateStore,
					asset: { name: 'nazar.lsk', ttl: 60 * 60, registerFor: 1 },
					transaction: { senderAddress: account.address } as any,
				});

				await transactionAsset.apply(context);

				await expect(transactionAsset.apply(context)).rejects.toThrow(
					'The name "nazar.lsk" already registered',
				);
			});
		});
	});
});
----

=== Testing the Reverse Lookup asset

The complete code of the tests for the Reverse Lookup asset is described below.
Most of the code is self-explanatory, but the most important parts of the tests are summarized here for a better overview:

==== Testing the apply() function

Tests for the <<state-change,apply() function>> of the Reverse Lookup asset.

Write tests to check the following:

* Valid cases:
** It should update the lns reverse-lookup of the sender account with given node if not already set.
** It should update the lns reverse-lookup of the sender account with given node even if already set.
* Invalid cases:
** It should throw error if node to set-lookup is not owned by sender.

Before each test:

* Create a new default account for the LNS application.
* Add two registered names to the account: `john.lsk` and `doe.lsk`.
* Add the newly created account to the `accounts` list of the `StateStore` mock.
* Spy on the functions `stateStore.chain.get` and `stateStore.chain.set`.
This allows to check in the tests, if the respective functions have been called or not.

Use of the SDK testing utilities:

* testing.createApplyAssetContext(): Returns valid parameters for the `apply()` function.
If the function is called with an empty object, it xref:{url_test_suite_createapplycontext}[returns the default parameters] for the `apply()` function.
For the test, overwrite the default `asset` value (`undefined`) with a valid transaction asset for the Reverse Lookup asset.
Additionally, overwrite the default transaction value of the context (`undefined`) with a transaction containing a property `senderAddress` which equals the address of the newly created account.
* testing.fixtures.createDefaultAccount<LNSAccountProps>([LnsModule]):
Used to create a default account for the LNS application.
* new testing.mocks.StateStoreMock({accounts: [account]}):
Creates a mock for the StateStore.

==== Unit tests for the Reverse Lookup asset

.lisk-name-service/lns/test/unit/modules/lns/assets/reverse_lookup.ts
[source,typescript]
----
import { chain, cryptography, StateStore, testing } from 'lisk-sdk';
import { ReverseLookupAsset } from '../../../../../src/app/modules/lns/assets/reverse_lookup';
import { LNSAccountProps } from '../../../../../src/app/modules/lns/data';
import { LnsModule } from '../../../../../src/app/modules/lns/lns_module';
import { getNodeForName } from '../../../../../src/app/modules/lns/storage';

describe('ReverseLookupAsset', () => {
	let transactionAsset: ReverseLookupAsset;

	beforeEach(() => {
		transactionAsset = new ReverseLookupAsset();
	});

	describe('constructor', () => {
		it('should have valid id', () => {
			expect(transactionAsset.id).toEqual(2);
		});

		it('should have valid name', () => {
			expect(transactionAsset.name).toEqual('reverse-lookup');
		});

		it('should have valid schema', () => {
			expect(transactionAsset.schema).toMatchSnapshot();
		});
	});

	describe('apply', () => {
		let stateStore: StateStore;
		let account: chain.Account<LNSAccountProps>;
		let ownNodes: Buffer[];

		beforeEach(() => {
			ownNodes = [getNodeForName('john.lsk'), getNodeForName('doe.lsk')];
			account = testing.fixtures.createDefaultAccount<LNSAccountProps>([LnsModule]);
			account.lns.ownNodes = ownNodes;

			stateStore = new testing.mocks.StateStoreMock({
				accounts: [account],
			});

			jest.spyOn(stateStore.chain, 'get');
			jest.spyOn(stateStore.chain, 'set');
		});

		describe('valid cases', () => {
			it('should update sender account lns reverse-lookup with given node if not already set', async () => {
				const context = testing.createApplyAssetContext({
					stateStore,
					asset: { name: 'john.lsk' },
					transaction: { senderAddress: account.address } as any,
				});
				await transactionAsset.apply(context);

				const updatedAccount = stateStore.account.get<LNSAccountProps>(account.address);

				expect((await updatedAccount).lns.reverseLookup).toEqual(ownNodes[0]);
			});

			it('should update sender account lns reverse-lookup with given node even if already set', async () => {
				account.lns.reverseLookup = cryptography.getRandomBytes(20);
				stateStore = new testing.mocks.StateStoreMock({
					accounts: [account],
				});
				const context = testing.createApplyAssetContext({
					stateStore,
					asset: { name: 'john.lsk' },
					transaction: { senderAddress: account.address } as any,
				});
				await transactionAsset.apply(context);

				const updatedAccount = stateStore.account.get<LNSAccountProps>(account.address);

				expect((await updatedAccount).lns.reverseLookup).toEqual(ownNodes[0]);
			});
		});

		describe('invalid cases', () => {
			it('should throw error if node to set-lookup is not owned by sender', async () => {
				const context = testing.createApplyAssetContext({
					stateStore,
					asset: { name: 'alpha.lsk' },
					transaction: { senderAddress: account.address } as any,
				});

				await expect(transactionAsset.apply(context)).rejects.toThrow(
					'You can only assign lookup node which you own.',
				);
			});
		});
	});
});
----

== Writing network tests


.lisk-name-service/lns/test/network/lns_modules.spec.ts
[source,typescript]
----
import { cryptography, passphrase, testing, transactions } from 'lisk-sdk';
import { LnsModule } from '../../src/app/modules/lns/lns_module';

jest.setTimeout(150000);

describe('LnsModule', () => {
	let appEnv: testing.ApplicationEnv;

	beforeAll(async () => {
		appEnv = testing.createDefaultApplicationEnv({ modules: [LnsModule] });
		await appEnv.startApplication();
	});

	afterAll(async () => {
		jest.spyOn(process, 'exit').mockImplementation((() => {}) as never);
		await appEnv.stopApplication();
	});

	describe('actions', () => {
		describe('resolveName', () => {
			it('should throw error on resolving non-registered name', async () => {
				await expect(appEnv.ipcClient.invoke('lns:resolveName', { name: 'nazar' })).rejects.toThrow(
					'Name "nazar" could not resolve.',
				);
			});

			it('should resolve name after registration', async () => {
				// Create an account
				const accountPassphrase = passphrase.Mnemonic.generateMnemonic();
				const { address } = cryptography.getAddressAndPublicKeyFromPassphrase(accountPassphrase);
				const account = testing.fixtures.createDefaultAccount([LnsModule], { address });

				// Fund with some tokens
				let tx = await appEnv.ipcClient.transaction.create(
					{
						moduleName: 'token',
						assetName: 'transfer',
						asset: {
							recipientAddress: account.address,
							amount: BigInt(transactions.convertLSKToBeddows('100')),
							data: '',
						},
						fee: BigInt(transactions.convertLSKToBeddows('0.1')),
					},
					testing.fixtures.defaultFaucetAccount.passphrase,
				);
				await appEnv.ipcClient.transaction.send(tx);
				await appEnv.waitNBlocks(1);

				tx = await appEnv.ipcClient.transaction.create(
					{
						moduleName: 'lns',
						assetName: 'register',
						asset: {
							registerFor: 1,
							name: 'nazar.lsk',
							ttl: 36000,
						},
						fee: BigInt(transactions.convertLSKToBeddows('0.1')),
					},
					accountPassphrase,
				);
				await appEnv.ipcClient.transaction.send(tx);
				await appEnv.waitNBlocks(1);

				await expect(
					appEnv.ipcClient.invoke('lns:resolveName', { name: 'nazar.lsk' }),
				).resolves.toEqual(
					expect.objectContaining({
						name: 'nazar.lsk',
						ownerAddress: address.toString('hex'),
						ttl: 36000,
						records: [],
					}),
				);
			});
		});
	});
});
----


----
$ tree -L 5 -I 'node_modules|test'
.
├── _setup.js
├── commands
│   └── account
│       └── create.spec.ts
├── integration
├── network
│   └── lns_modules.spec.ts
├── tsconfig.json
├── unit
│   └── modules
│       └── lns
│           ├── assets
│           │   ├── register.spec.ts
│           │   └── reverse_lookup.spec.ts
│           └── lns.spec.ts
└── utils
    └── config.ts
----
