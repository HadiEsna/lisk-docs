= Lisk Name Service (LNS) Tutorial
Mona Bärenfänger <mona@lightcurve.io>
// Settings
:toc: preamble
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
:experimental:
// URLs
:url_wikipedia_dns: https://en.wikipedia.org/wiki/Domain_Name_System
:url_ens: https://docs.ens.domains/

How to create a blockchain application that offers a domain name service for blockchain accounts, similar to {url_wikipedia_dns}[DNS^] and {url_ens}[ENS^].

This service allows an account to register one or multiple `.lsk` domains for a certain amount of time (1-5 years).

If an account registers a domain, it becomes a human readable identifier for the account and can then be used to refer to the account instead of the (less human-readable) Lisk32 account address.

Additionally, it is possible to create TXT and CNAME records for each domain owned by an account.

== LNS application overview
image:tutorials/lns/lns-overview.png[]

:sectnums:
== Dependencies

[options="header",]
|===
|Dependencies |Version
|Git | v2 (latest)
|Node.js | v12 (latest)
|Lisk Commander | v5.1.2 (latest)
|===

=== Node.js

If you are using NVM, install the correct version as shown below:

[source,bash]
----
nvm install v12.22.3
----

=== Lisk Commander

It is recommended to install Lisk Commander globally with NPM to facilitate the convenient usage of the Lisk Commander CLI.

[source,bash]
----
npm install --global lisk-commander
----

To check the successful installation of Lisk Commander, run for example:

[source,bash]
----
$ lisk --version
lisk-commander/5.1.2 darwin-x64 node-v12.22.3
----

== Bootstrapping the default application

Create a dedicated folder `lisk-name-service/`, which will contain the files for the application.

Inside of this folder, execute the `lisk init` command of Lisk Commander as shown below:

[source,bash]
----
mkdir lisk-name-service
cd lisk-name-service
lisk init
----

This will generate a lot of new files and folders, resulting in the following structure:

----
.
├── README.md
├── bin <1>
├── config <2>
├── jest.config.js
├── package-lock.json
├── package.json
├── src
│   ├── app <3>
│   │   ├── app.ts <4>
│   │   ├── index.ts
│   │   ├── modules <5>
│   │   ├── modules.ts <6>
│   │   ├── plugins <7>
│   │   └── plugins.ts <8>
│   └── commands <9>
├── test <10>
└── tsconfig.json
----

<1> `bin/` contains the `run` script which starts the application CLI.
<2> `config/` contains the default configuration and genesis block for the application.
<3> `app/` contains the files of the blockchain application.
<4> `app.ts` creates the `Application` instance.
<5> `modules/` contains the application modules (currently empty).
<6> `modules.ts` registers the modules with the application.
<7> `plugins/` contains the application plugins (currently empty).
<8> `plugins.ts` registers the plugins with the application.
<9> `commannds/` contains the application CLI commands.
<10> `tests/` contains functional, network and unit tests for the blockchain application.

This creates a ready-to-start blockchain application, configured for a local devnet, which uses only the default modules of the Lisk SDK.

The application is created in the file `app.ts`:

.lisk-name-service/src/app/app.ts
[source,typescript]
----
import { Application, PartialApplicationConfig, utils } from 'lisk-sdk';
import { registerModules } from './modules';
import { registerPlugins } from './plugins';

export const getApplication = (
	genesisBlock: Record<string, unknown>,
	config: PartialApplicationConfig,
): Application => {
	const app = Application.defaultApplication(genesisBlock, config); // <1>

	registerModules(app); // <2>
	registerPlugins(app); // <3>

	return app;
};
----

<1> Creates blockchain application with the default modules.
<2> Will register additionnal modules to the application.
Currently, no additionnal modules are available for the application.
To add new modules update the `modules.ts` file.
<3> Will register additionnal plugins to the application.
Currently, no plugins are available for the application.
To add new plugins update the `plugins.ts` file.

To verify the successful bootstrap of the blockchain application, start it with the following command:

.lisk-name-service/
[source,bash]
----
./bin/run start
----

And observe the displayed log messages in the console.
If on errors are thrown, the application will start to add new locks every 10 seconds after the initial startup.

Once it is veerified that the application runs correctly, stop the node again with kbd:[Ctrl] + kbd:[C].

To customize the default blockchain application to suit our desired use case, we will now generate the LNS module.

Create the module skeleton by using the command `lisk generate:module` like shown below:

.lisk-name-service/
[source,bash]
----
lisk generate:module lns 1000
----

The command expects two arguments:
 . The module name
 . The module ID

This will information will be used to create the corresponding module skeleton.

Read the following sections to learn how to further extend the LNS module to suit the desired use case.

== Creating the LNS module assets

The first part of the module that we implement here are the assets to handle thee different transaction types `register`, `reverse lookup` and `update records`.

=== Register Domain

[source,bash]
----
lisk generate:asset lns register 1
----

==== Schema

.src/app/modules/lns/data/assets/register.ts
[source,typescript]
----
	$id: 'lisk/lns/lnsAccount',
	type: 'object',
	required: ['ownNodes', 'reverseLookup'],
	properties: {
		reverseLookup: {
			dataType: 'bytes',
			fieldNumber: 1,
		},
		ownNodes: {
			type: 'array',
			fieldNumber: 2,
			items: {
				dataType: 'bytes',
			},
		},
	},
	default: {
		ownNodes: [],
		reverseLookup: EMPTY_BUFFER,
	},
};
----

==== Validation

.src/app/modules/lns/assets/register.ts
[source,typescript]
----
public validate({ asset }: ValidateAssetContext<RegisterAssetProps>): void {
    if (asset.ttl < MIN_TTL_VALUE) {
        throw new Error(`Must set TTL value larger or equal to ${MIN_TTL_VALUE}`);
    }

    if (asset.registerFor < 1) {
        throw new Error('You can register name at least for 1 year.');
    }

    if (asset.registerFor > 5) {
        throw new Error('You can register name maximum for 5 year.');
    }

    const chunks = asset.name.split(/\./);

    if (chunks.length > 2) {
        throw new Error('You can only register second level domain name.');
    }

    if (!VALID_TLDS.includes(chunks[1])) {
        throw new Error(`Invalid TLD found "${chunks[1]}". Valid TLDs are "${VALID_TLDS.join()}"`);
    }
}
----

==== State change

.src/app/modules/lns/assets/register.ts
[source,typescript]
----
public async apply({
		asset,
		stateStore,
		transaction,
	}: ApplyAssetContext<RegisterAssetProps>): Promise<void> {
		const node = getNodeForName(asset.name);
		const existingDomain = await getLNSObject(stateStore, node);

		if (existingDomain) {
			throw new Error(`The name "${asset.name}" already registered`);
		}

		const lnsObject = {
			name: asset.name,
			ttl: asset.ttl,
			expiry: Math.ceil(addYears(new Date(), asset.registerFor).getTime() / 1000),
			ownerAddress: transaction.senderAddress,
			records: [],
		};

		await createLSNObject(stateStore, lnsObject);

		const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);
		sender.lns.ownNodes = [...sender.lns.ownNodes, node];
		await stateStore.account.set(sender.address, sender);
	}
}
----

==== Utility functions

.src/app/modules/lns/storage.ts
[source,typescript]
----
import * as namehash from 'eth-ens-namehash';

// constants
export const LNS_PREFIX = 'LNS';
export const VALID_TLDS = ['lsk'];

// Get a unique key for each LNS object
export const getKeyForNode = (node: Buffer): string => `${LNS_PREFIX}:${node.toString('hex')}`;
// Create a hash from the domain name and return it as Buffer
export const getNodeForName = (name: string): Buffer =>
	Buffer.from(namehash.hash(name).slice(2), 'hex');
----

.src/app/modules/lns/storage.ts
[source,typescript]
----
export const getLNSObject = async (
	stateStore: StateStore,
	node: Buffer,
): Promise<LNSNode | undefined> => {
	const result = await stateStore.chain.get(getKeyForNode(node));

	if (!result) {
		return;
	}

	// eslint-disable-next-line consistent-return
	return codec.decode<LNSNode>(lnsNodeSchema, result);
};
----

.src/app/modules/lns/storage.ts
[source,typescript]
----
export const createLSNObject = async (
	stateStore: StateStore,
	params: Omit<LNSNode, 'createdAt' | 'updatedAt' | 'node'> & { name: string },
): Promise<void> => {
	const { name, ...lnsObject } = params;
	const node = getNodeForName(name);

	const input: LNSNode = {
		...lnsObject,
		name,
		createdAt: Math.ceil(Date.now() / 1000),
		updatedAt: Math.ceil(Date.now() / 1000),
	};

	await stateStore.chain.set(getKeyForNode(node), codec.encode(lnsNodeSchema, input));
};
----

.src/app/modules/lns/data/lns_node.ts
[source,typescript]
----
export interface LNSNode {
	ownerAddress: Buffer;
	name: string;
	ttl: number;
	expiry: number;
	records: LNSNodeRecord[];
	createdAt: number;
	updatedAt: number;
}
----

.src/app/modules/lns/data/lns_node.ts
[source,typescript]
----
export const lnsNodeSchema = {
	$id: 'lisk/lns/lnsNode',
	type: 'object',
	required: ['ownerAddress', 'name', 'ttl', 'expiry', 'records', 'createdAt', 'updatedAt'],
	properties: {
		ownerAddress: {
			dataType: 'bytes',
			fieldNumber: 1,
		},
		name: {
			dataType: 'string',
			fieldNumber: 2,
		},
		ttl: {
			dataType: 'uint32',
			fieldNumber: 3,
		},
		expiry: {
			dataType: 'uint32',
			fieldNumber: 4,
		},
		createdAt: {
			dataType: 'uint32',
			fieldNumber: 5,
		},
		updatedAt: {
			dataType: 'uint32',
			fieldNumber: 6,
		},
		records: {
			type: 'array',
			fieldNumber: 7,
			items: {
				...lnsNodeRecordSchema,
			},
		},
	},
};
----

.src/app/modules/lns/data/lns_node_records.ts
[source,typescript]
----
export interface LNSNodeRecord {
	type: number;
	label: string;
	value: string;
}
----

.src/app/modules/lns/data/lns_node_records.ts
[source,typescript]
----
export const lnsNodeRecordSchema = {
	$id: 'lisk/lns/lnsNodeRecord',
	type: 'object',
	required: ['type', 'label', 'value'],
	properties: {
		type: {
			dataType: 'uint32',
			fieldNumber: 1,
		},
		label: {
			dataType: 'string',
			fieldNumber: 2,
		},
		value: {
			dataType: 'string',
			fieldNumber: 3,
		}
	},
};
----
=== Update reverse lookup

[source,bash]
----
lisk generate:asset lns reverse_lookup 2
----

==== Schema
[source,typescript]
----
export const reverseLookupAssetPropsSchema = {
  $id: 'lns/assets/set-lookup',
  title: 'SetLookup transaction asset for lns module',
  type: 'object',
  required: ['name'],
  properties: {
    name: {
      dataType: 'string',
      fieldNumber: 1,
    },
  },
}
----
==== State change
[source,typescript]
----
public async apply({
    asset,
    stateStore,
    transaction,
}: ApplyAssetContext<ReverseLookupAssetProps>): Promise<void> {
    const node = getNodeForName(asset.name);
    const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);

    const exists = sender.lns.ownNodes.find(n => n.equals(node));

    if (!exists) {
        throw new Error('You can only assign lookup node which you own.');
    }

    sender.lns.reverseLookup = node;
    await stateStore.account.set(sender.address, sender);
}
----
=== Update records

[source,bash]
----
lisk generate:asset lns update_records 3
----

==== Schema
.src/app/modules/lns/data/assets/update_records.ts
[source,typescript]
----
export const updateRecordsAssetPropsSchema = {
  $id: 'lns/assets/update-records',
  title: 'Update Records transaction asset for lns module',
  type: 'object',
  required: ['records'],
  properties: {
    name: {
      dataType: 'string',
      fieldNumber: 1,
    },
    records: {
      type: 'array',
      fieldNumber: 2,
      items: {
				...lnsNodeRecordSchema,
			},
    }
  },
}
----
==== Validation
.src/app/modules/lns/assets/update_records.ts
[source,typescript]
----
public validate({ asset }: ValidateAssetContext<UpdateRecordsAssetProps>): void {
    if (asset.records.length > MAX_RECORDS) {
        throw new Error(`Can associate maximum ${MAX_RECORDS} records. Got ${asset.records.length}.`);
    }

    const recordKeys = new Set(asset.records.map(r => `${r.type.toString()}:${r.label}`));

    if (recordKeys.size !== asset.records.length) {
        throw new Error('Records should be unique among type and label');
    }

    for (const record of asset.records) {
        if (!VALID_RECORD_TYPES.includes(record.type)) {
            throw new Error(
                `Invalid record type "${
                    record.type
                }". Valid record types are ${VALID_RECORD_TYPES.join()}`,
            );
        }

        if (
            record.label.length > MAX_RECORD_LABEL_LENGTH ||
            record.label.length < MIN_RECORD_LABEL_LENGTH
        ) {
            throw new Error(
                `Record label can be between ${MIN_RECORD_LABEL_LENGTH}-${MAX_RECORD_LABEL_LENGTH}.`,
            );
        }

        if (
            record.value.length > MAX_RECORD_VALUE_LENGTH ||
            record.value.length < MIN_RECORD_VALUE_LENGTH
        ) {
            throw new Error(
                `Record value can be between ${MIN_RECORD_VALUE_LENGTH}-${MAX_RECORD_VALUE_LENGTH}.`,
            );
        }
    }
}
----

==== State change
.src/app/modules/lns/assets/update_records.ts
[source,typescript]
----
public async apply({
    asset,
    stateStore,
    transaction,
}: ApplyAssetContext<UpdateRecordsAssetProps>): Promise<void> {
    const sender = await stateStore.account.get<LNSAccountProps>(transaction.senderAddress);
    const node = getNodeForName(asset.name);
    const lnsObject = await getLNSObject(stateStore, node);

    if (!lnsObject) {
        throw new Error(`LNS object with name "${asset.name}" is not registered`);
    }

    if (!lnsObject.ownerAddress.equals(sender.address)) {
        throw new Error('Only owner of hte LNS object can update records.');
    }

    if (!isTTLPassed(lnsObject)) {
        throw new Error('You have to wait for TTL from the last update.');
    }

    await updateLSNObject(stateStore, { node, records: asset.records });
}
----

==== Utility functions

.src/app/modules/lns/storage.ts
[source,typescript]
----
export const updateLSNObject = async (
	stateStore: StateStore,
	params: Partial<Omit<LNSNode, 'createdAt' | 'updatedAt'>> & { node: Buffer },
): Promise<void> => {
	const lnsObject = await getLNSObject(stateStore, params.node);

	if (!lnsObject) {
		throw new Error('No lns object is associated with this name');
	}

	lnsObject.ttl = params.ttl ?? lnsObject.ttl;
	lnsObject.ownerAddress = params.ownerAddress ?? lnsObject.ownerAddress;
	lnsObject.expiry = params.expiry ?? lnsObject.expiry;
	lnsObject.records = params.records ?? lnsObject.records;

	lnsObject.updatedAt = Math.ceil(Date.now() / 1000);

	await stateStore.chain.set(getKeyForNode(params.node), codec.encode(lnsNodeSchema, lnsObject));
};
----

== Creating the LNS module
=== Assets
[source,typescript]
----
----
=== Actions
[source,typescript]
----
----
.src/app/modules/lns/storage.ts
[source,typescript]
----
----
=== Reducers
[source,typescript]
----
----
== Connecting the Dashboard plugin
[source,typescript]
----
----
== Extending the application CLI
[source,typescript]
----
----
== Using a plugin as frontend
[source,typescript]
----
----
== Writing unit tests
== Writing network tests
