= Modules and commands
Mona Bärenfänger <mona@lightcurve.io>
//Settings
:toc: preamble
:toclevels: 4
:idprefix:
:idseparator: -
:docs_sdk: lisk-sdk::
// URLs

A module is a separate component that contains blockchain-related business logic related to one specific domain or topic of a blockchain application.

Modules can be added to a blockchain application by registering them.
For a successful registration, each module needs to follow the expected module structure, which is described on this page.

All modules of a blockchain application combined define the complete *on-chain logic* of the blockchain application.

.Modules can perform the following:
****
* Executing state changes on the blockchain.
* Defining logic that is executed per block.
* Defining logic that is executed per transaction.
****

== Module anatomy & the BaseModule

All important parts of a module are shown in the diagram below.

.Anatomy of a module
image::understand-blockchain/sdk/module.png["Module Anatomy",600, align="center"]

Each module is constructed as a class which extends from the **BaseModule** interface.

The `BaseModule` interface defines all optional and required properties and hooks of a module that must be implemented for the blockchain application to recognize it as a valid module.

.The `BaseModule`
[source,typescript]
----
export abstract class BaseModule {
	public abstract id: Buffer;
	public abstract name: string;
	public abstract metadata(): ModuleMetadata;
	public abstract endpoint: BaseEndpoint;
	public abstract methods: BaseMethod;
	public commands: BaseCommand[] = [];

	public async init?(args: ModuleInitArgs): Promise<void>;
	public async insertAssets?(context: InsertAssetContext): Promise<void>;
	public async verifyAssets?(context: BlockVerifyContext): Promise<void>;
	public async verifyTransaction?(context: TransactionVerifyContext): Promise<VerificationResult>;
	public async beforeCommandExecute?(context: TransactionExecuteContext): Promise<void>;
	public async afterCommandExecute?(context: TransactionExecuteContext): Promise<void>;
	public async initGenesisState?(context: GenesisBlockExecuteContext): Promise<void>;
	public async finalizeGenesisState?(context: GenesisBlockExecuteContext): Promise<void>;
	public async beforeTransactionsExecute?(context: BlockExecuteContext): Promise<void>;
	public async afterTransactionsExecute?(context: BlockAfterExecuteContext): Promise<void>;
}
----

== Module ID

The module ID is the unique identifier for a module in the application.

The module IDs `0`-`999` are reserved for official modules for the Lisk SDK.
This means that the minimum ID for a new module is `1000`.
The module ID is stored in binary format.

It is also important to note, that module IDs do not need to be in succession, the only requirement is that they are unique within the blockchain application.
So as an example, it is valid to register multiple modules to the application which have the following module IDs: `1003`, `1000`, and `2500001` as they are in the allowed number range, and each ID is different.

.Example: ID of the Hello module from the Hello World app
[source,js]
----
import { cryptography, BaseModule } from 'lisk-sdk';

export class HelloModule extends BaseModule {
	public id = cryptography.utils.intToBuffer(1000, 4);

    // ...
}
----

== Module name

The module name is the human readable unique identifier for the module.

.Example: Name of the Hello module from the Hello World app
[source,js]
----
import { BaseModule } from 'lisk-sdk';

class HelloModule extends BaseModule {
    // ...
    public name = 'hello';
    // ...
}
----

== Module metadata

The metadata of a module provides information about the module to external services like UIs.

It provides information about the following module properties:

* *endpoints*: A list of endpoints of the respective module.
Each item has the following properties:
** `name`: The name of the endpoint.
** `request`: Required parameters for the endpoint (optional).
** `response`: A schema of the expected response to a request to the endpoint.
* *commands*: The list of commands belonging to the module.
Each item has the following properties:
** `id`: The command ID.
** `name`: The command name.
** `params`: The required and optional parameters to execute the command (optional).
* *events*: A list of events that are emitted by the module.
Each item has the following properties:
** `typeId`: The event type ID.
//TODO: describe event metadata
** `data`:
* *assets*: The schemas to decode module assets in blocks.
Each item has the following properties:
** `version`: The block version.
** `data`: The asset schema.

[[interface-metadata]]
.Interface for the Module metadata
[%collapsible]
====
[source,typescript]
----
export interface ModuleMetadata {
	endpoints: {
		name: string;
		request?: Schema;
		response: Schema;
	}[];
	events: {
		typeID: string;
		data: Schema;
	}[];
	commands: {
		id: Buffer;
		name: string;
		params?: Schema;
	}[];
	assets: {
		version: number;
		data: Schema;
	}[];
}

export interface Schema {
	readonly $id: string;
	readonly type: string;
	readonly properties: Record<string, unknown>;
	readonly required?: string[];
}
----
====

=== Defining the module metadata

The module metadata follows the format of the <<interface-metadata,module metadata interface>> and is returned in the `metadata()` function of a module.

.Example: Module metadata
[%collapsible]
====
//TODO: Replace the snippet below with a code example from Hello app
[source,typescript]
----
const { BaseModule } = require('lisk-sdk');

class HelloModule extends BaseModule {
    // ...

    public metadata(): ModuleMetadata {
        return {
            endpoints: [
                {
                    name: this.endpoint.getAllDelegates.name,
                    response: getAllDelegatesResponseSchema,
                },
                {
                    name: this.endpoint.getDelegate.name,
                    request: getDelegateRequestSchema,
                    response: getDelegateResponseSchema,
                },
                {
                    name: this.endpoint.getVoter.name,
                    request: getVoterRequestSchema,
                    response: getVoterResponseSchema,
                },
                {
                    name: this.endpoint.getConstants.name,
                    response: configSchema,
                },
            ],
            commands: this.commands.map(command => ({
                id: command.id,
                name: command.name,
                params: command.schema,
            })),
            events: [],
            assets: [
                {
                    version: 0,
                    data: genesisStoreSchema,
                },
            ],
        };
    }

    // ...
}
----

//TODO: Replace the snippet below with a code example from Hello app
.Example: Schema of the `getAllDelegatesResponse` endpoint of the DPoS module
[source,typescript]
----
export const getDelegateRequestSchema = {
	$id: 'modules/dpos/endpoint/getDelegateRequest',
	type: 'object',
	required: ['address'],
	properties: {
		address: {
			type: 'string',
			format: 'hex',
		},
	},
};
----
====

=== Obtaining and using metadata about a module

Metadata can be obtained


and used is


== Endpoints

An endpoint is the interface for a module to an external system through an RPC endpoint.
The module RPC endpoints of a blockchain application can be requested by external services, like a UIs, to get relevant data from the application.

The endpoints are defined individually for each module, depending on the module purpose.

IMPORTANT: Endpoints allow to conveniently *get data from the blockchain application*.
It is never possible to set data / mutate the state via module endpoints.

Every module endpoint always extends from the `BaseEndpoint` class.

.The `BaseEndpoint` class
[source,typescript]
----
export abstract class BaseEndpoint {
	[key: string]: unknown;
	protected moduleID: Buffer;
	public constructor(moduleID: Buffer) {
		this.moduleID = moduleID;
	}
}
----

=== Exposing endpoints to plugins and external services
The module endpoints are usually defined in a file called `endpoint.ts` inside of the folder of the respective module.

.Example: Module endpoint
[source,typescript]
----
import { HelloEndpoint } from './endpoint';
import { cryptography } from 'lisk-sdk';

export class HelloModule extends BaseModule {
	public id = cryptography.utils.intToBuffer(1000, 4);
	public name = 'hello';
	public endpoint = new HelloEndpoint(this.id);
}
----

//TODO: Update code snippet to use Hello app example
.Example: `HelloEndpoint` in `endpoint.ts`
[%collapsible]
====
[source,typescript]
----
export class DPoSEndpoint extends BaseEndpoint {

	public async getVoter(ctx: ModuleEndpointContext): Promise<VoterDataJSON> {
		const voterSubStore = ctx.getStore(this.moduleID, STORE_PREFIX_VOTER);
		const { address } = ctx.params;
		if (typeof address !== 'string') {
			throw new Error('Parameter address must be a string.');
		}
		const voterData = await voterSubStore.getWithSchema<VoterData>(
			Buffer.from(address, 'hex'),
			voterStoreSchema,
		);

		return codec.toJSON(voterStoreSchema, voterData);
	}
}
----
====

== Methods

A method is the interface for the module-to-module communication, and *can perform state mutations* on the blockchain.

Methods are called from other modules or by the module itself, if certain module-specific data is desired to get or set data in the blockchain.
For example, the `transfer` method from the `Token` module is called by a module, if it needs to transfer tokens from one account to the other.

.The `BaseMethod` class
[source,typescipt]
----
export abstract class BaseMethod {
	protected moduleID: Buffer;
	public constructor(moduleID: Buffer) {
		this.moduleID = moduleID;
	}
}
----

=== Exposing methods to other modules

Modules

.Example: Module methods
[source,typescript]
----
import { HelloMethod } from './api';
import { cryptography } from 'lisk-sdk';

export class HelloModule extends BaseModule {
	public id = cryptography.utils.intToBuffer(1000, 4);
	public name = 'hello';
	public api = new HelloMethod(this.id);
}
----

//TODO: Update code snippet to use Hello app example
.Example: `HelloMethod` in `methods.ts`
[%collapsible]
====
[source,typescript]
----
export class HelloMethod extends BaseMethod {

    // ...

	public async getVoter(apiContext: ImmutableAPIContext, address: Buffer): Promise<VoterData> {
		const voterSubStore = apiContext.getStore(this.moduleID, STORE_PREFIX_VOTER);
		const voterData = await voterSubStore.getWithSchema<VoterData>(address, voterStoreSchema);

		return voterData;
	}

    // ...
}
----
====

=== Calling a module method from another module

//TODO: Link to example of calling a mmodule in a command/hook
To see an example how to call a module method from another module, look at the following example in the module hooks.

////
[source,typescript]
----
const { EventQueue } = require('lisk-sdk');

const apiContext = createAPIContext({ stateStore, eventQueue: new EventQueue() });
const voterDataReturned = await dposAPI.getVoter(apiContext, address);
----

.From a command
[source,typescript]
----
public async execute(context: CommandExecuteContext<Params>): Promise<void> {
    const { params } = context;
    await this._api.transfer(
        context.getAPIContext(),
        context.transaction.senderAddress,
        params.recipientAddress,
        params.tokenID,
        params.amount,
    );
}
----

.From a module hook
[source,typescript]
----
public async beforeCommandExecute(context: TransactionExecuteContext): Promise<void> {
    const minFee =
        BigInt(this._minFeePerByte * context.transaction.getBytes().length) +
        this._extraFee(context.transaction.moduleID, context.transaction.commandID);
    const senderAddress = address.getAddressFromPublicKey(context.transaction.senderPublicKey);
    const apiContext = context.getAPIContext();

    const isNative = await this._tokenAPI.isNative(apiContext, this._tokenID);
    if (isNative) {
        await this._tokenAPI.burn(apiContext, senderAddress, this._tokenID, minFee);
        await this._tokenAPI.transfer(
            apiContext,
            senderAddress,
            context.header.generatorAddress,
            this._tokenID,
            context.transaction.fee - minFee,
        );

        return;
    }

    await this._tokenAPI.transfer(
        apiContext,
        senderAddress,
        context.header.generatorAddress,
        this._tokenID,
        context.transaction.fee,
    );
}
----

== Logger

The logger is accessible inside of a module under `this._logger`.
As the name suggests, the logger creates log messages for the module for the different log levels:

* trace
* debug
* info
* warn
* error
* fatal

[source,js]
----
this._logger.debug(nextRound, 'Updating delegate list for');
----

The logger expects 2 arguments:

. Data of the log message (object).
. Message of the log message (string).


== Genesis config

The genesis configuration is accessible in a module under the variable `this.config`.

[source,js]
----
console.log(this.config.blockTime);
// 10
----

== Interfaces
Modules can expose interfaces (<<actions>>, and <<events>>), which allow other components of the application to interact with the module.

<<actions>> and <<events>> are exposed to xref:{url_intro_plugins}[] and to external services.

TIP: View the "Interfaces" section of the xref:{url_advanced_communication_interfaces}[Communication] page to see an overview about the different interfaces and their accessibility in modules, plugins, and external services.

=== dataAccess

Use the property `this._dataAccess` to access data from the blockchain in the module.

TIP: Updating and changing of data on the blockchain is only allowed inside of <<assets>> and <<lifecycle-hooks>> via <<the-state-store>>.

[source,js]
----
const res = await this._dataAccess.getChainState('hello:helloCounter');
----

[NOTE]
====
The data is encoded in the database, therefore it needs to be decoded after receiving it with `this._dataAccess`.

For more information about this topic, check out the xref:{url_advanced_schemas}[] page.
====

The following functions are available via `this._dataAccess`:

[source,js]
----
export interface BaseModuleDataAccess {
	getChainState(key: string): Promise<Buffer | undefined>;
	getAccountByAddress<T>(address: Buffer): Promise<Account<T>>;
	getLastBlockHeader(): Promise<BlockHeader>;
}
----

=== Actions

Actions are functions which can be xref:{url_advanced_communication_invoke_actions}[invoked] via Remote-Procedure-Calls (RPC) by plugins and external services, to request data from the module.

.Example: Actions of the Hello module from the Hello World app
[source,js]
----
actions = {
    amountOfHellos: async () => {
        const res = await this._dataAccess.getChainState(CHAIN_STATE_HELLO_COUNTER);
        const count = codec.decode(
            helloCounterSchema,
            res
        );
        return count;
    },
};
----

=== Events

Events are xref:{url_advanced_communication_moduleschannel}[published] by the module on relevant occasions.
Plugins and external services can xref:{url_advanced_communication_publishsubscribe}[subscribe] to these events and as a result, they will be notified immediately every time a new event is published.

.Example: Events of the Hello module from the Hello World app
[source,js]
----
events = ['newHello'];
----

== State changes & execution logic

The parts which contain the logic to perform state mutation on the blockchain are possibly the most important part of the module, as they define the underlying business logic and general behavior of a module.

It is possible to change the state of the blockchain in the xref:{url_understand_reducers}[], <<lifecycle-hooks>> or <<assets>> of a module.

IMPORTANT: All of the logic implemented in a module / asset must be “deterministic” and executable within the block time.

=== The state store

The `stateStore` is used to mutate the state of the blockchain data, or to retrieve data from the blockchain.

Inside of a module, the `stateStore` is available for xref:{url_understand_reducers}[], <<assets>> and all <<lifecycle-hooks>>.

.Interface of `stateStore`
[source,typescript]
----
interface StateStore {
	readonly account: {
		get<T = AccountDefaultProps>(address: Buffer): Promise<Account<T>>;
		getOrDefault<T = AccountDefaultProps>(address: Buffer): Promise<Account<T>>;
		set<T = AccountDefaultProps>(address: Buffer, updatedElement: Account<T>): Promise<void>;
		del(address: Buffer): Promise<void>;
	};
	readonly chain: {
		lastBlockHeaders: ReadonlyArray<BlockHeader>;
		lastBlockReward: bigint;
		networkIdentifier: Buffer;
		get(key: string): Promise<Buffer | undefined>;
		set(key: string, value: Buffer): Promise<void>;
	};
}
----

=== Commands

Assets are responsible for executing logic that introduces state changes on the blockchain, based on input parameters which are provided by the users as transactions.

A blockchain application can accept many different kinds of transactions, depending on its use case.
Every transaction type is handled by a specific <<assets,asset>> of a module in the application.
The xref:{url_advanced_architecture_defaultapp}[default application] already supports the following transactions:

* xref:{url_references_token_module}[]: xref:{url_protocol_accounts_transfer}[Token transfer]
* xref:{url_references_dpos_module}[]:
** xref:{url_protocol_accounts_delegate}[Delegate registration]
** xref:{url_protocol_accounts_vote}[Vote delegate]
** xref:{url_protocol_accounts_unlock}[Unlock token]
** xref:{url_protocol_accounts_pom}[Delegate misbehavior report]
// * xref:{url_references_keys_module}[]: xref:{url_protocol_accounts_multisignature}[Multisignature group registration]

To add support for a new transaction to the application, it is required to implement a new asset and to add the asset to a module.

.Example: Assets of the Hello module from the Hello World app
[source,js]
----
transactionAssets = [ new HelloAsset() ];
----

TIP: To learn how to create a new asset, check out the xref:{url_guides_asset}[] guide.

==== Command anatomy

Each asset is constructed as a class which extends from the xref:{url_references_framework_baseasset}[BaseAsset].

The base asset provides an interface which needs to be completed by implementing the described components of an asset which are shown in the diagram below.

image::understand-blockchain/sdk/command.png[,600, align="center"]

==== Transaction asset schema

The asset schema defines the *custom data structure of the transaction*.

It defines which properties are required in the transaction asset, and also which data types are to be expected.

If a transaction object does not match the corresponding schema, the transaction will not be accepted by the node.

Asset schemas are defined in a modified JSON schema.
For more information about this topic, check out the xref:{url_advanced_schemas}[] page.

.Example of an asset schema
[source,js]
----
schema = {
    $id: 'lisk/hello/asset', // <1>
    type: 'object',
    required: ["helloString"], // <2>
    properties: { // <3>
        helloString: {
            dataType: 'string',
            fieldNumber: 1,
        },
    }
};
----

<1> The ID under which assets are saved in the database.
Must be unique.
<2> All properties of the asset must be defined as required.
<3> Contains the properties of the transaction asset.

==== Validate

As the name suggests, the `validate()` function validates the posted transaction data to check that it contains the expected format.

The following variables are available inside the `validate()` function:

* `asset`: The custom data of the transaction (defined in <<transaction-asset-schema>>), posted to the node.
* `transaction`: The complete transaction object which was posted to the node.

If the function throws any errors, the transaction will not be applied by the node.

If the function does not throw any errors, the transaction will passed to the `apply()` function.

.Example: validate() function of the CreateNFT asset of the NFT example app
[source,js]
----
validate({asset}) {
    if (asset.name === "Mewtwo") {
        throw new Error("Illegal NFT name: Mewtwo");
    }
};
----

==== Apply

The `apply()` function of an asset applies the desired business logic on the blockchain, based on the data posted in the transaction.

The following variables are available inside the `apply()` function:

* `asset`: The custom data of the transaction (defined in <<transaction-asset-schema>>), posted to the node.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See xref:{url_reducerhandler}[reducerHandler].
* `transaction`: The complete transaction object which was posted to the node.

.Example: apply() function of the Hello asset of the Hello World example app
[source,js]
----
async apply({ asset, stateStore, reducerHandler, transaction }) {
    // Get sender account details
    const senderAddress = transaction.senderAddress;
    const senderAccount = await stateStore.account.get(senderAddress);
    // Add the hello string to the sender account
    senderAccount.hello.helloMessage = asset.helloString;
    stateStore.account.set(senderAccount.address, senderAccount);
    // Get the hello counter and decode it
    let counterBuffer = await stateStore.chain.get(
        CHAIN_STATE_HELLO_COUNTER
    );
    let counter = codec.decode(
        helloCounterSchema,
        counterBuffer
    );
    // Increment the hello counter by +1
    counter.helloCounter++;
    // Save the updated counter on the chain
    await stateStore.chain.set(
        CHAIN_STATE_HELLO_COUNTER,
        codec.encode(helloCounterSchema, counter)
    );
}
----

=== Lifecycle Hooks

Lifecycle hooks allow the execution of logic at specific moments in the xref:{url_advanced_architecture_lifecycle}[] of the application.

image::intro/lifecycle-hooks.png[,600, align="center"]

.Example: afterTransactionApply() of the Hello module from the Hello World app
[source,js]
----
async afterTransactionApply({transaction, stateStore, reducerHandler}) {
  // If the transaction is a hello transaction
  if (transaction.moduleID === this.id && transaction.assetID === HelloAssetID) {
    // Decode the transaction asset
    const helloAsset = codec.decode(
      helloAssetSchema,
      transaction.asset
    );

    // And publish a new hello:newHello event,
    // including the latest hello message and the sender.
    this._channel.publish('hello:newHello', {
      sender: transaction._senderAddress.toString('hex'),
      hello: helloAsset.helloString
    });
  }
};
----

==== beforeTransactionApply()
This hook is applied before each transaction.

The following variables are available inside this hook:

* `transaction`: The complete transaction object which was posted to the node.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See xref:{url_reducerhandler}[reducerHandler].
* `this._channel`: See xref:{url_advanced_communication_moduleschannel}[Channel for modules].

==== afterTransactionApply()
This hook is applied after each transaction.

The following variables are available inside this hook:

* `transaction`: The complete transaction object which was posted to the node.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See xref:{url_reducerhandler}[reducerHandler].
* `this._channel`: See xref:{url_advanced_communication_moduleschannel}[Channel for modules].

==== afterGenesisBlockApply()
This hook is applied after the genesis block.

The following variables are available inside this hook:

* `genesisBlock`: The xref:{url_advanced_architecture_genesisblock}[genesis block] of the application.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See xref:{url_reducerhandler}[reducerHandler].
* `this._channel`: See xref:{url_advanced_communication_moduleschannel}[Channel for modules].

==== beforeBlockApply()
This hook is applied before each block.

The following variables are available inside this hook:

* `block`: The block before it is applied on the blockchain.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See xref:{url_reducerhandler}[reducerHandler].
* `this._channel`: See xref:{url_advanced_communication_moduleschannel}[Channel for modules].

==== afterBlockApply()
This hook is applied after each block.

The following variables are available inside this hook:

* `block`: The block after it is applied on the blockchain.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See xref:{url_reducerhandler}[reducerHandler].
* `this._channel`: See xref:{url_advanced_communication_moduleschannel}[Channel for modules].
* `consensus`: See <<consensus>>.

==== Consensus

`consensus` offers different consensus related functions to get and set the list of xref:{url_active_delegate}[active delegates], and to get the finalized height of the blockchain.

.consensus interface
[source,typescript]
----
{
	getDelegates: () => Promise<Delegate[]>; // <1>
	updateDelegates: (delegates: Delegate[]) => Promise<void>; // <2>
	getFinalizedHeight: () => number; // <3>
}
----

<1> Get a list of the actively forging delegates in the current round.
<2> Update the list of delegates for the current round.
<3> Returns the currently finalized height of the blockchain.

== Account schema

The account schema allows a module to store module-specific data in the user accounts footnote:account_footnote[].

The definition of this schema is totally flexible and it is possible to define very complex data structures as well if necessary.

Account schemas are defined in a modified JSON schema.
For more information about this topic, check out the xref:{url_advanced_schemas}[] page.

.Example: Account schema of the Hello module from the Hello World app
[source,js]
----
accountSchema = {
    type: 'object',
    properties: {
        helloMessage: {
            fieldNumber: 1,
            dataType: 'string',
        },
    },
    default: {
        helloMessage: '',
    },
};
----

The defined properties in the account schema will be available for every user account.
They will be grouped under a key named after the <<module-name>>.

If a module with the module name `hello` is registered in a xref:{url_advanced_architecture_defaultapp}[default application] with the above example of an account schema, the user accounts would appear as shown below:

NOTE: The properties `token`, `sequence`, `keys`, and `dpos` exist in the user account, as the blockchain application already has several modules xref:{url_intro_bapps_defaultmodules}[registered by default].

.Example user account
[source,js]
----
{
  "address": "ae6fff8b9c9c3a8b38193d2186638f684d64d887",
  "token": {
    "balance": "20000000000"
  },
  "sequence": {
    "nonce": "0"
  },
  "keys": {
    "numberOfSignatures": 0,
    "mandatoryKeys": [],
    "optionalKeys": []
  },
  "dpos": {
    "delegate": {
      "username": "",
      "pomHeights": [],
      "consecutiveMissedBlocks": 0,
      "lastForgedHeight": 0,
      "isBanned": false,
      "totalVotesReceived": "0"
    },
    "sentVotes": [],
    "unlocking": []
  },
  "hello": {
    "helloMessage": ""
  }
}
----

////