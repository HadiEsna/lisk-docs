= Modules and commands
Mona Bärenfänger <mona@lightcurve.io>
//Settings
:toc: preamble
:toclevels: 4
:idprefix:
:idseparator: -
:docs_sdk: lisk-sdk::
// URLs
:url_json_schema: https://json-schema.org/specification.html
:url_json_schema_id: https://json-schema.org/understanding-json-schema/structuring.html#id
// Project URLs
:url_understand_block_generation: understand-blockchain/index.adoc#block-generation
:url_understand_block_execution: understand-blockchain/index.adoc#block-execution
:url_understand_genesis_block_execution: understand-blockchain/index.adoc#genesis-block-execution
// Footnotes
:fn_jsonschema: footnote:jsonSchema[See the {url_json_schema} for more information about the JSON schema.]

A module is a separate component that contains blockchain-related business logic related to one specific domain or topic of a blockchain application.

Modules can be added to a blockchain application by registering them.
For a successful registration, each module needs to follow the expected module structure, which is described on this page.

All modules of a blockchain application combined define the complete *on-chain logic* of the blockchain application.

.Modules can perform the following:
****
* Executing state changes on the blockchain.
* Defining logic that is executed per block.
* Defining logic that is executed per transaction.
****

== Module anatomy & the BaseModule

All important parts of a module are shown in the diagram below.

.Anatomy of a module
image::understand-blockchain/sdk/module.png["Module Anatomy",600, align="center"]

Each module is constructed as a class which extends from the **BaseModule** interface.

The `BaseModule` interface defines all optional and required properties and hooks of a module that must be implemented for the blockchain application to recognize it as a valid module.

.The `BaseModule`
[source,typescript]
----
export abstract class BaseModule {
	public abstract id: Buffer;
	public abstract name: string;
	public abstract metadata(): ModuleMetadata;
	public abstract endpoint: BaseEndpoint;
	public abstract methods: BaseMethod;
	public commands: BaseCommand[] = [];

	public async init?(args: ModuleInitArgs): Promise<void>;
	public async insertAssets?(context: InsertAssetContext): Promise<void>;
	public async verifyAssets?(context: BlockVerifyContext): Promise<void>;
	public async verifyTransaction?(context: TransactionVerifyContext): Promise<VerificationResult>;
	public async beforeCommandExecute?(context: TransactionExecuteContext): Promise<void>;
	public async afterCommandExecute?(context: TransactionExecuteContext): Promise<void>;
	public async initGenesisState?(context: GenesisBlockExecuteContext): Promise<void>;
	public async finalizeGenesisState?(context: GenesisBlockExecuteContext): Promise<void>;
	public async beforeTransactionsExecute?(context: BlockExecuteContext): Promise<void>;
	public async afterTransactionsExecute?(context: BlockAfterExecuteContext): Promise<void>;
}
----

== Module ID

The module ID is the unique identifier for a module in the application.

The module IDs `0`-`999` are reserved for official modules for the Lisk SDK.
This means that the minimum ID for a new module is `1000`.
The module ID is stored in binary format.

It is also important to note, that module IDs do not need to be in succession, the only requirement is that they are unique within the blockchain application.
So as an example, it is valid to register multiple modules to the application which have the following module IDs: `1003`, `1000`, and `2500001` as they are in the allowed number range, and each ID is different.

.Example: ID of the Hello module
[source,js]
----
import { cryptography, BaseModule } from 'lisk-sdk';

export class HelloModule extends BaseModule {
	public id = cryptography.utils.intToBuffer(1000, 4);

    // ...
}
----

== Module name

The module name is the human-readable unique identifier for the module.

.Example: Name of the Hello module
[source,js]
----
import { BaseModule } from 'lisk-sdk';

class HelloModule extends BaseModule {
    // ...
    public name = 'hello';
    // ...
}
----

== Module metadata

The metadata of a module provides information about the module to external services like UIs.

It provides information about the following module properties:

* *endpoints*: A list of endpoints of the respective module.
Each item has the following properties:
** `name`: The name of the endpoint.
** `request`: Required parameters for the endpoint (optional).
** `response`: A schema of the expected response to a request to the endpoint.
* *commands*: The list of commands belonging to the module.
Each item has the following properties:
** `id`: The command ID.
** `name`: The command name.
** `params`: The required and optional parameters to execute the command (optional).
* *events*: A list of events that are emitted by the module.
Each item has the following properties:
** `typeId`: The event type ID.
//TODO: describe event metadata
** `data`:
* *assets*: The schemas to decode module assets in blocks.
Each item has the following properties:
** `version`: The block version.
** `data`: The asset schema.

//TODO: Add link to the respective rpc endpoint
The metadata can be obtained by requesting the metadata from the blockchain application via RPC request to the `system_getMetadata` endpoint.

[[interface-metadata]]
.Interface for the Module metadata
[%collapsible]
====
[source,typescript]
----
export interface ModuleMetadata {
	endpoints: {
		name: string;
		request?: Schema;
		response: Schema;
	}[];
	events: {
		typeID: string;
		data: Schema;
	}[];
	commands: {
		id: Buffer;
		name: string;
		params?: Schema;
	}[];
	assets: {
		version: number;
		data: Schema;
	}[];
}

export interface Schema {
	readonly $id: string;
	readonly type: string;
	readonly properties: Record<string, unknown>;
	readonly required?: string[];
}
----
====

=== Defining the module metadata

The module metadata follows the format of the <<interface-metadata,module metadata interface>> and is returned in the `metadata()` function of a module.

.Example: Module metadata
[%collapsible]
====
//TODO: Replace the snippet below with a code example from Hello app
[source,typescript]
----
const { BaseModule } = require('lisk-sdk');

class HelloModule extends BaseModule {
    // ...

    public metadata(): ModuleMetadata {
        return {
            endpoints: [
                {
                    name: this.endpoint.getAllDelegates.name,
                    response: getAllDelegatesResponseSchema,
                },
                {
                    name: this.endpoint.getDelegate.name,
                    request: getDelegateRequestSchema,
                    response: getDelegateResponseSchema,
                },
                {
                    name: this.endpoint.getVoter.name,
                    request: getVoterRequestSchema,
                    response: getVoterResponseSchema,
                },
                {
                    name: this.endpoint.getConstants.name,
                    response: configSchema,
                },
            ],
            commands: this.commands.map(command => ({
                id: command.id,
                name: command.name,
                params: command.schema,
            })),
            events: [],
            assets: [
                {
                    version: 0,
                    data: genesisStoreSchema,
                },
            ],
        };
    }

    // ...
}
----

//TODO: Replace the snippet below with a code example from Hello app
.Example: Schema of the `getAllDelegatesResponse` endpoint of the DPoS module
[source,typescript]
----
export const getDelegateRequestSchema = {
	$id: 'modules/dpos/endpoint/getDelegateRequest',
	type: 'object',
	required: ['address'],
	properties: {
		address: {
			type: 'string',
			format: 'hex',
		},
	},
};
----
====

== Endpoints

An endpoint is the interface for a module to an external system through an RPC endpoint.
The module RPC endpoints of a blockchain application can be requested by external services, like a UIs, to get relevant data from the application.

The endpoints are defined individually for each module, depending on the module purpose.

IMPORTANT: Endpoints allow to conveniently *get data from the blockchain application*.
It is never possible to set data / mutate the state via module endpoints.

Every module endpoint always extends from the `BaseEndpoint` class.

.The `BaseEndpoint` class
[source,typescript]
----
export abstract class BaseEndpoint {
	[key: string]: unknown;
	protected moduleID: Buffer;
	public constructor(moduleID: Buffer) {
		this.moduleID = moduleID;
	}
}
----

=== Exposing endpoints to plugins and external services
The module endpoints are usually defined in a file called `endpoint.ts` inside of the folder of the respective module.

.Example: Module endpoint
[source,typescript]
----
import { HelloEndpoint } from './endpoint';
import { cryptography } from 'lisk-sdk';

export class HelloModule extends BaseModule {
	public id = cryptography.utils.intToBuffer(1000, 4);
	public name = 'hello';
	public endpoint = new HelloEndpoint(this.id);
}
----

//TODO: Update code snippet to use Hello app example
.Example: `HelloEndpoint` in `endpoint.ts`
[%collapsible]
====
[source,typescript]
----
export class DPoSEndpoint extends BaseEndpoint {

	public async getVoter(ctx: ModuleEndpointContext): Promise<VoterDataJSON> {
		const voterSubStore = ctx.getStore(this.moduleID, STORE_PREFIX_VOTER);
		const { address } = ctx.params;
		if (typeof address !== 'string') {
			throw new Error('Parameter address must be a string.');
		}
		const voterData = await voterSubStore.getWithSchema<VoterData>(
			Buffer.from(address, 'hex'),
			voterStoreSchema,
		);

		return codec.toJSON(voterStoreSchema, voterData);
	}
}
----
====

== Methods

A method is the interface for the module-to-module communication, and *can perform state mutations* on the blockchain.

Methods are called from other modules or by the module itself, if certain module-specific data is desired to get or set data in the blockchain.
For example, the `transfer` method from the `Token` module is called by a module, if it needs to transfer tokens from one account to the other.

Every module method always extends from the `BaseMethod` class.

.The BaseMethod class
[source,typescript]
----
export abstract class BaseMethod {
	protected moduleID: Buffer;
	public constructor(moduleID: Buffer) {
		this.moduleID = moduleID;
	}
}
----

=== Exposing methods to other modules

The module methods are usually defined in a file called `methods.ts` inside of the folder of the respective module.

.Example: Module methods
[source,typescript]
----
import { HelloMethod } from './api';
import { cryptography } from 'lisk-sdk';

export class HelloModule extends BaseModule {
	public id = cryptography.utils.intToBuffer(1000, 4);
	public name = 'hello';
	public api = new HelloMethod(this.id);
}
----

//TODO: Update code snippet to use Hello app example
.Example: `HelloMethod` in `methods.ts`
[%collapsible]
====
[source,typescript]
----
export class HelloMethod extends BaseMethod {

    // ...

	public async getVoter(apiContext: ImmutableAPIContext, address: Buffer): Promise<VoterData> {
		const voterSubStore = apiContext.getStore(this.moduleID, STORE_PREFIX_VOTER);
		const voterData = await voterSubStore.getWithSchema<VoterData>(address, voterStoreSchema);

		return voterData;
	}

    // ...
}
----
====

=== Calling a module method from another module

//TODO: Link to example of calling a module in a command/hook
To see an example how to call a module method from another module, look at the following example in the module hooks.

== Module configuration

A module can access specific configuration options of the blockchain application:

. Module-specific configuration options
. Genesis config options

//TODO: include example snippets of module and genesis configurations

If a module needs to access certain configuration options, it is required to obtain the respective configurations in the `init()` method of a module, like described in the code snippet below.

[source,typescript]
----
public async init(args: ModuleInitArgs): Promise<void> {
    const { genesisConfig, moduleConfig } = args;
    const config = objects.mergeDeep({}, defaultConfig, moduleConfig);
    validator.validate<ModuleConfig>(configSchema, config);

    this._tokenID = Buffer.from(config.feeTokenID, 'hex');
    this._minFeePerByte = genesisConfig.minFeePerByte;
    this._baseFees = genesisConfig.baseFees.map(fee => ({ ...fee, baseFee: BigInt(fee.baseFee) }));
}
----

== Commands

A command is a group of *state-transition logics triggered by a transaction*, identified by the module and command name of the transaction.

image::understand-blockchain/sdk/command.png["Command anatomy",600, align="center"]

Every module method always extends from the `BaseCommand` class.

.The BaseCommand class
[source,typescript]
----
export abstract class BaseCommand<T = unknown> {
	public schema?: Schema;

	protected moduleID: Buffer;
	public abstract name: string;
	public abstract id: Buffer;

	public constructor(moduleID: Buffer) {
		this.moduleID = moduleID;
	}

	public verify?(context: CommandVerifyContext<T>): Promise<VerificationResult>;

	public abstract execute(context: CommandExecuteContext<T>): Promise<void>;
}
----

=== Command ID


[source,typescript]
----
const CREATE_HELLO_ID = 0;
export class TransferCommand extends BaseCommand {
	public id = cryptography.utils.intToBuffer(CREATE_HELLO_ID, 4);
	// ...
}
----

=== Command name

The command identifier.
Needs to be unique within the module the command belongs to.

[source,typescript]
----
export class TransferCommand extends BaseCommand {
    // ...
	public name = 'transfer';
    // ...
}
----

=== Command parameters schema

If the command has parameters, the parameters schema is defined in the `schema` property of a command.
It defines which parameters are optional and/or required in the transaction, and also which data types are to be expected.

If a transaction object does not match the corresponding schema, the transaction will not be accepted by the node.
The schema follows the format of a modified JSON schema{fn_jsonschema}, and should contain the following properties:

$id::
Unique identifier of the schema throughout the system.

The `$id` property is directly inherited from the JSON-schema.
You can read more about the id property on {url_json_schema_id}[^].

In general, adhere to the following criteria:

* Use unique IDs across the system.
* Use path like format for easy readability, (it is not an actual requirement).

In order to ensure no mixing of any schema with other registered schemas occurs, use one fixed identifier for your app in each ID.

title:: A short description of the schema.
type or dataType::
If the data type of a property is either an `object` or an `array`, the `type` property must be used instead of `dataType`.
Root type of the schema must be type object.
required::
A list of all required parameters.

TIP: If the schema is used for serialization, it is recommended to put all properties as required to guarantee the uniqueness of encoding.

properties::
A list of the command parameters.
It also defines their data type, order, and additional properties like min and max length.

.Example: Command parameters schema
[%collapsible]
====
[source,typescript]
----
export class TransferCommand extends BaseCommand {
	// ...
	public schema = {
        $id: '/lisk/transferParams',
        title: 'Transfer transaction params',
        type: 'object',
        required: ['tokenID', 'amount', 'recipientAddress', 'data'],
        properties: {
            tokenID: {
                dataType: 'bytes',
                fieldNumber: 1,
                minLength: TOKEN_ID_LENGTH,
                maxLength: TOKEN_ID_LENGTH,
            },
            amount: {
                dataType: 'uint64',
                fieldNumber: 2,
            },
            recipientAddress: {
                dataType: 'bytes',
                fieldNumber: 3,
                minLength: ADDRESS_LENGTH,
                maxLength: ADDRESS_LENGTH,
            },
            data: {
                dataType: 'string',
                fieldNumber: 4,
                minLength: 0,
                maxLength: MAX_DATA_LENGTH,
            },
        },
    };
    // ...
}
----
====

=== Command Lifecycle Hooks

Each command has the following lifecycle hooks, which are executed separately for each command in a block.

==== Command initialization

If a command needs to access module methods, it is required to obtain the respective methods in the `init()` method of a command, like described in the code snippet below.

[source,typescript]
----
export class TransferCommand extends BaseCommand {
    // ...
	private _api!: TokenMethods;
	public init(args: { api: TokenMethods }) {
		this._api = args.api;
	}
    // ...
}
----
==== Command verification
The hook `Command.verify` is called only for the command that is referenced by the module name and the command name in the transaction.
Similar to the `verifyTransaction` hook, `Command.verify` will be called also in the transaction pool, and it is to ensure the verification defined in this hook is respected when the transactions are included in a block.

NOTE: In this hook, the *state cannot be mutated* and events cannot be emitted.

[source,typescript]
----
export class TransferCommand extends BaseCommand {
	// ...
	public async verify(context: CommandVerifyContext<Params>): Promise<VerificationResult> {
		const { params } = context;

		try {
			validator.validate(transferParamsSchema, params);
		} catch (err) {
			return {
				status: VerifyStatus.FAIL,
				error: err as Error,
			};
		}
		return {
			status: VerifyStatus.OK,
		};
	}
    // ...
}
----
==== Command execution

Applies the state changes through the state machine.
The hook `Command.execute` is triggered by a transaction identified by the module name and the command name.

If the hook execution fails, the transaction that triggered this command is still valid, but the state changes applied during this hook are reverted.
Additionally, an event will be emitted that provides the information whether a command is executed successfully or failed.

NOTE: In this hook, the *state can be mutated* and events can be emitted.

[source,typescript]
----
export class TransferCommand extends BaseCommand {
	// ...
	public async execute(context: CommandExecuteContext<Params>): Promise<void> {
		const { params } = context;
		await this._api.transfer(
			context.getAPIContext(),
			context.transaction.senderAddress,
			params.recipientAddress,
			params.tokenID,
			params.amount,
		);
	}
}
----

===== Command execution context

== Lifecycle Hooks

The module hooks are called in a specific order during block creation and execution.

Read more about the block lifecycles in the following sections:
. xref:{url_understand_genesis_block_execution}[Lisk key concepts > Genesis block execution]
. xref:{url_understand_block_generation}[Lisk key concepts > Block generation]
. xref:{url_understand_block_execution}[Lisk key concepts > Block processing]

IMPORTANT: Never include external dynamic data to state changes in the lifecycle hooks.
It will create inconsistencies/forks for nodes when syncing to the current height.

=== insertAssets
The hook `insertAssets` is called at the very beginning of the xref:{url_understand_block_generation}[block generation].
The assets added during the execution of this hook can be used in all the execution hooks afterwards.

//TODO: Add link to random module
For example, the `seedReveal` property is added to the block asset in this hook by the Random module.

=== verifyAssets
The hook `verifyAssets` is only called before xref:{url_understand_block_execution}[executing a block].

If this stage fails, the block is considered invalid and will be rejected.
In particular, the following hooks will not get executed.

This hook is used for verification before any state changes.
For example, at this stage, each module checks if the expected assets exist in the block.

NOTE: In this hook, the *state cannot be mutated* and events cannot be emitted.

=== beforeTransactionsExecute

The hook `beforeTransactionsExecute` is triggered before any of the transactions of the block are processed.

NOTE: In this hook, the *state can be mutated* and events can be emitted.

=== verifyTransaction

The hook `verifyTransaction` is called for all the transactions within a block regardless of the command they trigger.
This ensures that all transactions included in a block satisfy the verifications defined in this hook.

This hook is used also for transaction verification in the transaction pool to reject invalid transactions early before transmitting them to the network.
For example, signature verification is done in this hook.

NOTE: In this hook, the *state cannot be mutated* and events cannot be emitted.

=== beforeCommandExecute
The hook `beforeCommandExecute` allows adding business logic before the execution of a command.
It is called for all the transactions within a block regardless of the command they trigger.

If the hook fails during the execution, the transaction becomes invalid and the block containing this transaction will be invalid.

NOTE: In this hook, the *state can be mutated* and events can be emitted.

=== afterCommandExecute
The hook `afterCommandExecute` allows adding business logic after the execution of a command.
It is called for all the transactions within a block regardless of the command they trigger.

If the hook fails during the execution, the transaction becomes invalid and the block containing this transaction will be invalid.

NOTE: In this hook, the *state can be mutated* and events can be emitted.

=== afterTransactionsExecute
The hook `afterTransactionsExecute` is the last hook allowed to define state changes that are triggered by the block.

Additionally, when defining the `afterTransactionsExecute` logic for a module, the transactions included in the block are available in that context and can be used in this logic.
For example, this hook can be used to sum the fees of the transactions included in a block and transfer them to the block generator.

NOTE: In this hook, the *state can be mutated* and events can be emitted.

=== initGenesisState
The hook `initGenesisState` is called at the beginning of the xref:{url_understand_genesis_block_execution}[genesis block execution].
Each module must initialize their state using an associated block asset.

It is recommended not to use methods from other modules because their state might not be initialized yet depending on the order of the hook execution.

=== finalizeGenesisState
The hook `finalizeGenesisState` is called at the end of xref:{url_understand_genesis_block_execution}[genesis block execution].

In this hook, it can be assumed that the state initialization via `initGenesisState` of every module is completed and therefore methods from other modules can be used.