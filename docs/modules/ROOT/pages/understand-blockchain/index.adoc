= Understand Lisk blockchain
Muhammad Talha <muhammad.talha@lightcurve.io>
//Settings
:toc: preamble
:idprefix:
:idseparator: -
:fn_gpk: footnote:generatorPublicKey[Previously the `generatorPublicKey` property (see https://github.com/LiskHQ/lips/blob/main/proposals/lip-0055.md#change-generator-public-key-to-generator-address[LIP 0055^] for more information).]
:fn_eventroot: footnote:eventroot[See https://github.com/LiskHQ/lips/blob/main/proposals/lip-0065.md[LIP 0065^] for the reason why it needs to be included in a block header.]
:fn_stateroot: footnote:stateroot[See https://github.com/LiskHQ/lips/blob/main/proposals/lip-0040.md[LIP 0040^] for the reason why it needs to be included in a block header.]
:fn_aggregate: footnote:aggregate[See https://github.com/LiskHQ/lips/blob/main/proposals/lip-0061.md[LIP 0061^] for more details.]
// URLs
:url_lip55: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0055.md
// Project URLs
:url_intro_how_blockchain_works: intro/how-blockchain-works.adoc#state-machine
:url_intro_consensus: intro/how-blockchain-works.adoc#consensus-mechanisms
:url_understand_state_machine: understand-blockchain/state-machine.adoc
:url_understand_consensus: understand-blockchain/consensus/index.adoc
:url_understand_network: understand-blockchain/network.adoc
:url_understand_state_machine_tree: understand-blockchain/state-machine.adoc#the-blockchain-state-as-sparse-merkle-tree
:url_understand_sdk_commands: understand-blockchain/sdk/modules-assets.adoc#assets
:url_understand_sdk_modules: understand-blockchain/sdk/modules-assets.adoc
:lisk_service: lisk-service::

//External URLs
:url_lisk_roadmap: https://lisk.com/roadmap
:url_github_lns_dashboard: https://github.com/LiskHQ/lisk-sdk-examples/tree/nh-lisk-name-service/tutorials/lisk-name-service/lns-dashboard-plugin
:url_github_srs: https://github.com/LiskHQ/lisk-sdk-examples/tree/development/tutorials/social-recovery
:url_blog_benchmark: https://lisk.com/blog/development/benchmarking-lisk-core-v3.0.0-against-lisk-core-v2.1.6-0
:url_lisk_apps: https://lisk.com/ecosystem
//Project URLs
:url_introduction_modules: understand-blockchain/sdk/modules-assets.adoc
:url_introduction_plugins: understand-blockchain/sdk/plugins.adoc
:url_advanced_communication: understand-blockchain/sdk/rpc.adoc
:url_advanced_architecture_config: {docs_sdk}config.adoc
:url_advanced_communication_actions: understand-blockchain/sdk/rpc.adoc#actions
:url_advanced_communication_events: understand-blockchain/sdk/rpc.adoc#events
:url_protocol: understand-blockchain/lisk-protocol/index.adoc
:url_protocol_blocks: understand-blockchain/lisk-protocol/blocks.adoc
:url_protocol_consensus: understand-blockchain/lisk-protocol/consensus-algorithm.adoc#voting_and_weight
:url_protocol_transactions: understand-blockchain/lisk-protocol/transactions.adoc
:url_references_forger_plugin: {docs_sdk}plugins/forger-plugin.adoc
:url_references_monitor_plugin: {docs_sdk}plugins/monitor-plugin.adoc
:url_references_report_misbbehavior_plugin: {docs_sdk}plugins/report-misbehavior-plugin.adoc
:url_references_dpos_module: {docs_sdk}modules/dpos-module.adoc
:url_references_token_module: {docs_sdk}modules/token-module.adoc
:url_tutorials_nft: tutorial/nft.adoc
:url_tutorials_srs: tutorial/srs.adoc
:url_integrate_ui: integrate-blockchain/create-user-interface.adoc
:url_lisk_service: {lisk_service}index.adoc
In the "Understand Lisk blockchain" category you learn the basic concepts of Lisk based blockchain applications, including how they are structured and which topics and terms are important to know when developing within the Lisk ecosystem.

This page gives an overview of what Lisk Blockchain is? what are the key elements of a Lisk blockchain? what are blockchain applications and Lisk protocol? and how information flows through the Lisk Blockchain?

== What is Lisk Blockchain?

A blockchain is a chain of interconnected blocks that exist on various nodes distributed across a P2P network.
Each node keeps their own copy of the blockchain protocol and related data. 
It syncs periodically with other nodes to make sure that the records of the node are up to date.

The Lisk blockchain also follows the same principal.
It is a combination of a interconnected main chain and many side chains.
Each side chain is registered to the mainchain and is specific to a blockchain application.
Unlike Ethereum, where dApps have to share the same chain for their blockchain needs, Lisk provides the oppertunity for each application to have their own side chain.

This enables slower growth of a chain as information is only recieved from a single blockchain application.
It also provides faster block generation and lessens the burden on the network.
These side chains can also communicate with other side chains with the help of <<Lisk\'s Cross Chain Communication protocol>>.

Applications built with Lisk blockchains are called "blockchain applications". These applications can have customized logic, UIs  and a blockchain as their application's database.
An overview of what Lisk Blockchain is all about can be seen in the following diagram.

image::understand-blockchain/lisk-blockchain-overview.png["Lisk blockchain overview", 500, align="center"]

xref:{url_lisk_service}[Lisk Service] is a platform that allows interaction with various blockchain networks based on Lisk protocols.
Whilst building a blockchain application with a customized UI, it is recommended to use the off the shelf Lisk Service that provides an interface to communicate with the blockchain network.

== What are blockchain applications?

A blockchain application is any kind of application which uses its' own blockchain as a database layer.

More specifically, within the Lisk documentation, every time we talk about blockchain applications, we are referring to applications running on blockchains that are compatible with xref:{url_protocol}[].

Blockchain applications are highly customizeable as the Lisk protocol allows, creation of a scalable UI and business logic on top of Lisk Service. 

=== Architecture of a blokchain application






.Examples of blockchain applications
****
Examples of blockchain applications can be found in the tutorials, such as the xref:{url_tutorials_nft}[], or the xref:{url_tutorials_srs}[] application.

Additionally, check out the apps list at {url_lisk_apps}[^]
****









=== Blockchain applications vs. dApps
As blockchain applications are also in a sense decentralized applications, you may wonder what is the difference between blockchain applications and dApps, or if there is any difference at all.

In short, the main difference between dApps and blockchain applications is that blockchain applications each run on their own blockchain/sidechain, while dApps are sharing the blockchain network with other dApps.

dApps are generally constructed as smart contracts, for example on the Ethereum blockchain.
The development of blockchain applications is quite different, because it is much more similar to building a normal web application.

Most functionalities of smart contracts can be implemented in blockchain applications much easier and in a more straight forward manner.
However, there is one important difference here to dApps, when it comes to applying new <<on-chain-logic>> to the application:
New smart contracts can be directly applied on the running blockchain, while adding new on-chain logic to blockchain applications always requires a hard fork in the network.
Therefore, blockchain applications are less flexible than dApps, when it comes to uploading new logic on the running chain.

If the flexible characteristics of smart contracts are desired inside a blockchain application, it is of course also possible to develop a blockchain application which supports smart contracts.
For example, a new module could be added to the application, which accepts smart contracts.
This way it is possible to have the best of both worlds combined.

Additionally, smart contracts can reuse an already existing blockchain, which saves time when launching the application, as it is not necessary to take care of setting up an independent blockchain network, finding delegates footnote:delegate_footnote[For more information about delegates, check the xref:{url_protocol_consensus}[Consensus algorithm] page of the Lisk protocol.], etc.

Blockchain applications on the contrary rely on their own blockchain, and therefore also need to take care of maintaining their own network.
In the beginning, this will make the launch of the application slightly more complex, however, having an independent network comes with numerous benefits which are covered in the following paragraphs.

The Lisk documentation is referring to applications built with the Lisk SDK as "blockchain applications" and not "dApps". In order to clarify the difference here, applications are not sharing a common blockchain, but instead are each running on their own chain.
As a result blockchain applications have the following advantages:

* Lower transaction fees, as high traffic of one blockchain application has no effect on other blockchain applications.
* The blockchain for the application can be designed with the optimal characteristics for the specific use case, (for example by adjusting the block time or the number of delegates, or even changing the whole consensus algorithm).
* A much more scalable blockchain, as it only handles the data from one blockchain application.
Therefore it is growing much slower in size, and doesn't suffer so much from potential bottlenecks in the network, which can happen during times of high workload on many different dApps.
* Interoperability: Register a blockchain application as a sidechain to connect it to the Lisk Mainchain, (this is coming {url_lisk_roadmap}[soon^]).
This will provide seamless interoperability to the Lisk Mainchain and all of its' connected sidechains.









== Architecture of blockchain applications
At a higher level, The Lisk protocol is divided into two major components: an application and an engine. These components contain various elements that work together to form the Lisk Protocol.


At its core their are two 




An application, engine, a set of Plugins, Modules and Configuration which is passed to every blockchain application.
Each play their own part to make sure that blockchain applications work correctly. 

For example, The Application takes care of the state mutation of the Lisk Blockchain, in simple terms, each new piece of data stored on the blockchain changes its state to some extent.

This happens with the help of the Application Component.
The Application component houses a state machine.
The job of the state machine is to interact with Modules and Plugins registered with the Blockchain.

The Lisk protocol is divided into five major components. 

* *Application:* The application is a gateway to the Lisk engine. Its job is to house Modules, Plugins and State Machine and enable a communication between for Lisk Protocol. 

** *Modules* describe the logic that changes the state of a blockchain. For example, if Bob wants to sends 10 LSKs to Alice then, behind the scenes a module will verify the validity of such a request and then will ask the State machine to transfer 10 LSKs from Bob's account to Alice's account. Modules aid the statemachine to transition state with verified and validated data.

** *Plugins* Due to Lisk's layered architecture, it is important for something to bridge the outside world with a Lisk protocol. 
A plugins does that, it connects the Lisk Blockchain with external softwares, services and user interfaces.
A plugins' job is not to change the state of the blockchain but to provide an interface between external softwares, services and user interfaces etc.
Infact, a Plugin can be used to create a UI for a blockchain application, however we recommend a more scalable way in <<Your Web Application>>


** *State machine* as the name suggests, a state machine is relevant to states of a machine, Lisk protocol relies heavily on its state machine to mutate state of a blockchain. 

states: A state machine typically has a set of different states that it can enter. For example, a padlock represented as state machine would have the two states "Open" and "Locked".

transitions: a set of allowable operations that change from one state to another. For example, to change from state "Open" to "Locked", a transition would be "Close padlock", and from "Locked" to "Open", it would be "Insert key & turn".
Each instance of a Lisk is replicated to a node.


=== Network topology diagram


=== Engine
==== Transaction Pool
==== Generator
==== Consensus
==== Chain
==== RPC
==== P2P
=== Network

=== Application
==== State Machine

=== Data Stores
==== State DB
==== Module DB
==== Node DB
==== Blockchain DB
==== Generator DB
==== Communication interfaces / APIs








In the "Understand Lisk blockchain" category you learn the basic concepts of Lisk based blockchain applications, including how they are structured and which topics and terms are important to know when developing within the Lisk ecosystem.






This page explains the three domains of a blockchain, and gives introduction to blocks and transactions.

== The three domains of a blockchain

At a high level, there are three domains of a blockchain:

.The three domains of a blockchain application
image::understand-blockchain/3-domains.png["3 domains of blockchain", 300, align="center"]

. **Application domain**: Responsible for verifying data and transitioning the blockchain state with deterministic logic via the xref:{url_understand_state_machine}[state machine].
. xref:{url_understand_consensus}[Consensus domain]: Responsible for the replication of the same sequence of states among all nodes in the network.
This is achieved by nodes in the network following a xref:{url_intro_consensus}[consensus protocol] and utilizing the application and network domains.
. xref:{url_understand_network}[Network domain]: Responsible for the communication of the peer-to-peer network.


****
The Lisk SDK is an open-source software development kit which enables developers to build scalable <<blockchain-applications>> in JavaScript.
****


== Blockchain applications

=== What are blockchain applications?

A blockchain application is any kind of application which uses its' own blockchain as a database layer.

More specifically, within the Lisk documentation, every time we talk about blockchain applications, we are referring to applications running on blockchains that are compatible with xref:{url_protocol}[].

.Examples of blockchain applications
****
Examples of blockchain applications can be found in the tutorials, such as the xref:{url_tutorials_nft}[], or the xref:{url_tutorials_srs}[] application.

Additionally, check out the apps list at {url_lisk_apps}[^]
****

=== Network topology diagram
A blockchain application generally consists of a network of servers, which are also called *nodes* in this context.

A typical network of nodes is illustrated in the diagram below:

image:intro/node-network.png[]

.Shared on-chain logic, optional off-chain logic
****
All nodes in the network need to share the same <<on-chain-logic>> (Modules), while the <<off-chain-logic>> (Plugins) of the application may differ from node to node.
****

==== P2P: Unstructured partial mesh network
The P2P network of nodes is unstructured, which means that all nodes are equal participants in the network.

It is also a partial mesh network, which means that every node is only connected to a small subset of nodes in the network.

Unstructured partial mesh networks allow nodes to share information in the network in a very expeditious and secure manner with all other nodes.
They also possess the ability to scale extremely well, even for large networks with thousands of connected nodes.

=== Architecture of blockchain applications

All important components of a blockchain application are displayed in the diagram below:

image:architecture.png[lisk-framework-architecture]

==== On-chain logic

The on-chain architecture is a layer of abstraction that provides a collection of features to configure and run any business logic on the blockchain.

In short, the on-chain logic covers the following points:

* introduces state mutations through blocks footnote:block_footnote[For more information about blocks, check out the xref:{url_protocol_blocks}[] page of the Lisk protocol.] or transactions footnote:tx_footnote[For more information about transactions, check the xref:{url_protocol_transactions}[] page of the Lisk protocol.].
* is part of the blockchain protocol.
* is verifiable by anyone by synchronizing with the blockchain.
* is located in modules.

.When to create a module
****
xref:{url_introduction_modules}[] are able to perform the following criteria:

* Define how data is stored on the blockchain.
* Define logic which is executed per block footnote:block_footnote[].
* Define logic which is executed per transaction footnote:tx_footnote[].
****

[[default-modules]]
The following modules are already included in the default application, they provide a basic blockchain application with a DPoS blockchain which allows basic token transfers between users:

xref:{url_references_dpos_module}[], xref:{url_references_token_module}[]
// , xref:{url_references_keys_module}[], xref:{url_references_sequence_module}[]

To extend and customize the application, register additional modules to the application.

To add a new module to your application, either reuse an already existing module from another blockchain application, or create a new module based on the specific requirements of your application.

==== Off-chain logic
In short, the off-chain logic covers the following points:

* It introduces new blockchain application features.
* It is not part of the blockchain protocol.
* It is optional to execute on a full node.
* It is located in plugins.

.When to create a plugin
****
xref:{url_introduction_plugins}[] are able to perform the following:

* search the blockchain data.
* aggregate the blockchain data.
* provide a UI for the blockchain application.
* automate the blockchain logic, such as automatically sending transactions.
* add a proxy to the application interfaces.
****

The default application does not include any plugins by default, however, the Lisk SDK is bundled with a few common plugins listed below, which can be imported directly:

xref:{url_references_http_plugin}[], xref:{url_references_forger_plugin}[], xref:{url_references_monitor_plugin}[], xref:{url_references_report_misbbehavior_plugin}[]

To extend and customize the application, register the desired plugins to the application.

To add a new plugin to your application, either reuse an already existing plugin from another blockchain application, or create a new plugin based on the specific requirements of your application.

=== Communication interfaces / APIs

image::intro/communication-architecture.png[,600 ,align="center"]

The communication architecture of the Lisk SDK allows internal application components and external services to communicate to the blockchain application via various channels.

The Lisk SDK provides two industry standard communication protocols: Inter Process Communication (IPC) and Web Sockets (WS).
The communication protocol of the blockchain application is changed in the xref:{url_advanced_architecture_config}[configuration].

It is possible to communicate to modules and plugins directly by invoking xref:{url_advanced_communication_actions}[actions] via a RPC request, or by subscribing to xref:{url_advanced_communication_events}[events].

It is recommended to use the IPC/WebSocket protocols where possible, as they provide a more enhanced performance in regard to the response times, (see the blog post: {url_blog_benchmark}[Benchmarking Lisk Core v3.0.0 against Lisk Core v2.1.6]).
// However, if you prefer an HTTP API, it is possible to add support for custom APIs by registering additional plugins, such as the xref:{url_references_http_plugin}[].
//We also recommend to try out xref:{url_service}[Lisk Service], which provides a much more comprehensive API compared to the HTTP API plugin.

For more information about the communication architecture, check out the xref:{url_advanced_communication}[endpoints explanation].

=== Frontend & backend

Blockchain applications usually consist of a frontend and a backend part, just as normal web applications.

In contrast to normal server-client applications, there is not one central backend, but rather a whole network of nodes which together secure and maintain the status of the blockchain.
Each node can handle complex business logic and provides a flexible and customizable API.
The blockchain itself is used as a database layer for the application.

The frontend allows users to interact conveniently with the blockchain application.
The implementation of a frontend is totally flexible.
For example, this can be achieved in the following ways:

[loweralpha]
. Create a new xref:{url_introduction_plugins}[plugin] for the blockchain application.
An example implementation of a frontend as a plugin is the {url_github_lns_dashboard}[LNS UI plugin] for the example application *Lisk Name Service*.
. Use your favorite framework/ programming language to develop a user interface, and communicate to the node via the <<communication-interfaces-apis>>.
One example is the frontend of the {url_github_srs}[SRS example application^] , which has been developed with React.js.
Another example is the UI for the Hello World application, detailed in the guide xref:{url_integrate_ui}[].
. For later requirements in a production environment, a middleware similar to Lisk Service should be used, which will aggregate the data from the blockchain network and possibly other 3rd party sources as well.
The frontend can then request this data via API requests from the middleware.

image::intro/ui-diagrams.png[]

== Blockchain applications vs. dApps

As blockchain applications are also in a sense decentralized applications, you may wonder what is the difference between blockchain applications and dApps, or if there is any difference at all.

In short, the main difference between dApps and blockchain applications is that blockchain applications each run on their own blockchain/sidechain, while dApps are sharing the blockchain network with other dApps.

dApps are generally constructed as smart contracts, for example on the Ethereum blockchain.
The development of blockchain applications is quite different, because it is much more similar to building a normal web application.

Most functionalities of smart contracts can be implemented in blockchain applications much easier and in a more straight forward manner.
However, there is one important difference here to dApps, when it comes to applying new <<on-chain-logic>> to the application:
New smart contracts can be directly applied on the running blockchain, while adding new on-chain logic to blockchain applications always requires a hard fork in the network.
Therefore, blockchain applications are less flexible than dApps, when it comes to uploading new logic on the running chain.

If the flexible characteristics of smart contracts are desired inside a blockchain application, it is of course also possible to develop a blockchain application which supports smart contracts.
For example, a new module could be added to the application, which accepts smart contracts.
This way it is possible to have the best of both worlds combined.

Additionally, smart contracts can reuse an already existing blockchain, which saves time when launching the application, as it is not necessary to take care of setting up an independent blockchain network, finding delegates footnote:delegate_footnote[For more information about delegates, check the xref:{url_protocol_consensus}[Consensus algorithm] page of the Lisk protocol.], etc.

Blockchain applications on the contrary rely on their own blockchain, and therefore also need to take care of maintaining their own network.
In the beginning, this will make the launch of the application slightly more complex, however, having an independent network comes with numerous benefits which are covered in the following paragraphs.

The Lisk documentation is referring to applications built with the Lisk SDK as "blockchain applications" and not "dApps". In order to clarify the difference here, applications are not sharing a common blockchain, but instead are each running on their own chain.
As a result blockchain applications have the following advantages:

* Lower transaction fees, as high traffic of one blockchain application has no effect on other blockchain applications.
* The blockchain for the application can be designed with the optimal characteristics for the specific use case, (for example by adjusting the block time or the number of delegates, or even changing the whole consensus algorithm).
* A much more scalable blockchain, as it only handles the data from one blockchain application.
Therefore it is growing much slower in size, and doesn't suffer so much from potential bottlenecks in the network, which can happen during times of high workload on many different dApps.
* Interoperability: Register a blockchain application as a sidechain to connect it to the Lisk Mainchain, (this is coming {url_lisk_roadmap}[soon^]).
This will provide seamless interoperability to the Lisk Mainchain and all of its' connected sidechains.





























// == Blocks

// Blocks following the Lisk protocol have three main properties:

// . <<block-header>>: includes properties relevant to the xref:{url_understand_consensus}[consensus] domain.
// . <<block-assets>>: an array of objects containing data injected by the blockchain application during the block creation.
// . <<transactions>>: The transactions included in the block.
// Each block can include a maximum of 15 kB of transactions.

// .Anatomy of a block
// image::understand-blockchain/block.png["Anatomy of a Lisk block",300,align="center"]

// Detailed descriptions of the main properties of a block are provided in the following sections.

// .Block JSON schema
// [%collapsible]
// ====
// Blocks are serialized and deserialized accordingly to the following JSON schema.

// [source,js]
// ----
// blockSchema = {
//   "type": "object",
//   "required": ["header", "transactions", "assets"],
//   "properties": {
//     "header": {
//       "dataType": "bytes",
//       "fieldNumber": 1
//     },
//     "transactions": {
//       "type": "array",
//       "fieldNumber": 2,
//       "items": {
//         "dataType": "bytes"
//       }
//     },
//     "assets": {
//       "type": "array",
//       "fieldNumber": 3,
//       "items": {
//         "dataType": "bytes"
//       }
//     }
//   }
// }
// ----
// ====

// === Block header

// Properties handled by the xref:{url_understand_consensus}[consensus] domain are added to the block header.

// .Block ID
// NOTE: The block ID is calculated by hashing the complete block header of a signed block.

// The most important properties of the block header are:

// * `timestamp`: Time the block was created as Unix timestamp.
// * `height`: The height of a block is always `= height of the previous block + 1`.
// * `previousBlockID`: The ID of the previous block.
// * `generatorAddress`: The address of the block generator{fn_gpk}.
// * `transactionRoot`: The transaction root is the root of the Merkle tree built from the ID of the <<transactions,transactions contained in the block>>.
// * `stateRoot`: The root of the sparse Merkle tree that is computed from the state of the blockchain.
// The state root is the root of the sparse Merkle tree built from the state of the chain after the block has been processed{fn_stateroot}.

// Beside the above properties, each block header contains various additional properties, required for deeper technical aspects of the blockchain application.
// Expand below boxes for a description of the additional properties, and see the JSON schema for an overview of all properties included in the header.
// Check {url_lip55}[LIP 0055^] for additional information about the block header.

// .Remaining properties of the block header
// [%collapsible]
// ====
// * `version`: The block header version must be equal the value of a block of the previous protocol plus one.
// * `assetRoot`: The root of the Merkle tree computed from the <<block-assets>> array.
// * `eventRoot`: The root of the sparse Merkle tree that is computed from the events emitted during the block processing{fn_eventroot}.
// //TODO: Add link to Lisk BFT explanation
// * `maxHeightPrevoted`: This property is related to the Lisk-BFT protocol and is used for the fork choice rule.
// //TODO: Add link to Lisk BFT explanation
// * `maxHeightGenerated`: This property is related to the Lisk-BFT protocol and is used to check for contradicting block headers.
// //TODO: Add link to Lisk interoperability explanation about certificates
// * `validatorsHash`: This property authenticates the set of validators active from the next block onward.
// It is important for cross-chain certification and included in certificates.
// * `aggregateCommit`: This property contains the aggregate BLS signature for a certificate and the height of the certified block.
// It attests that all signing validators consider the corresponding block final.
// Based on this, any node can create a certificate for the given height{fn_aggregate}.
// * `signature`: Signature of the validator who created the block.
// ====

// .Block header JSON schema
// [%collapsible]
// ====
// Block headers are serialized and deserialized accordingly to the following JSON schema.

// [source,js]
// ----
// blockHeaderSchema = {
//   "type": "object",
//   "required": [
//     "version",
//     "timestamp",
//     "height",
//     "previousBlockID",
//     "generatorAddress",
//     "transactionRoot",
//     "assetRoot",
//     "eventRoot",
//     "stateRoot",
//     "maxHeightPrevoted",
//     "maxHeightGenerated",
//     "validatorsHash",
//     "aggregateCommit",
//     "signature"
//   ],
//   "properties": {
//     "version": {
//       "dataType": "uint32",
//       "fieldNumber": 1
//     },
//     "timestamp": {
//       "dataType": "uint32",
//       "fieldNumber": 2
//     },
//     "height": {
//       "dataType": "uint32",
//       "fieldNumber": 3
//     },
//     "previousBlockID": {
//       "dataType": "bytes",
//       "fieldNumber": 4
//     },
//     "generatorAddress": {
//       "dataType": "bytes",
//       "fieldNumber": 5
//     },
//     "transactionRoot": {
//       "dataType": "bytes",
//       "fieldNumber": 6
//     },
//     "assetRoot": {
//       "dataType": "bytes",
//       "fieldNumber": 7
//     },
//     "eventRoot": {
//       "dataType": "bytes",
//       "fieldNumber": 8
//     },
//     "stateRoot": {
//       "dataType": "bytes",
//       "fieldNumber": 9
//     },
//     "maxHeightPrevoted": {
//       "dataType": "uint32",
//       "fieldNumber": 10
//     },
//     "maxHeightGenerated": {
//       "dataType": "uint32",
//       "fieldNumber": 11
//     },
//     "validatorsHash": {
//       "dataType": "bytes",
//       "fieldNumber": 12
//     },
//     "aggregateCommit": {
//       "type": "object",
//       "fieldNumber": 13,
//       "required": [
//         "height",
//         "aggregationBits",
//         "certificateSignature"
//       ],
//       "properties": {
//         "height": {
//           "dataType": "uint32",
//           "fieldNumber": 1
//         },
//         "aggregationBits": {
//           "dataType": "bytes",
//           "fieldNumber": 2
//         },
//         "certificateSignature": {
//           "dataType": "bytes",
//           "fieldNumber": 3
//         }
//       }
//     },
//     "signature": {
//       "dataType": "bytes",
//       "fieldNumber": 14
//     }
//   }
// }
// ----
// ====

// === Block assets

// Block assets allow the blockchain application to store specific data inside of each block.

// //TODO: Add link to state-machine page, merkle trees
// Each entry of the block assets is then inserted in a Merkle tree, whose root is included in the <<block-header>> as the `assetRoot` property.

// NOTE: Inserting the assets root rather than the full assets allows to bound the size of the block header to a fixed size, while still authenticating the content of the block assets.

// As an example, blockchains created with the Lisk SDK that implement the Random module, will insert the seed reveal property in the block assets.

// ==== JSON schema

// The schema for the block assets allows each xref:{url_understand_sdk_modules}[module] to include its serialized data individually, which makes the inclusion of module data very flexible.

// Each module can insert a single entry in the assets.
// This entry is an object containing a `moduleID` property, indicating the ID of the module handling it, and a generic data property that can contain arbitrary serialized data.

// .Block asset schema
// [%collapsible]
// ====
// [source,js]
// ----
// assetSchema = {
//   "type": "object",
//   "required": ["moduleID", "data"],
//   "properties": {
//     "moduleID": {
//       "dataType": "bytes",
//       "fieldNumber": 1
//     },
//     "data": {
//       "dataType": "bytes",
//       "fieldNumber": 2
//     }
//   }
// }
// ----
// ====

// == Transactions

// Transactions are sent to the blockchain application by its users to trigger state mutations on the blockchain.

// To be accepted by the blockchain application, the transactions must be transmitted in the expected format, including all the required properties of a transaction, and pass the transaction & command verification steps explained in the <<block-processing>> process description.

// Valid transactions trigger the corresponding xref:{url_understand_sdk_commands}[command] of a module that accepts this transaction type.
// Therefore, each transaction always needs to include the IDs of the module and command that the transaction wants to trigger.
// If any specific data input from the user is needed to complete the command, they are included under the `params` property of a transaction.
// Beside this, there are a few additional properties which every transaction should contain, which are described in image _Figure 3_ and below.

// //TODO: Add link to tx pool explanation
// After a transaction is sent to a node, it is first added to the transaction pool, waiting to be included in a block.
// The transactions to be included in the block are then always picked from there.

// .Properties of a transaction object
// image::understand-blockchain/transaction.png["Transaction properties",300, align="center"]

// * `moduleID`: An integer identifying the module the transaction is addressing.
// * `commandID`: An integer identifying the specific command in the module.
// * `nonce`: An integer which is *unique for each transaction* from the account corresponding to the `senderPublicKey`.
// Increments by `+1` for each transaction.
// * `fee`: An integer that specifies the *fee in Beddows* to be spent by the transaction.
// * `senderPublicKey`: The public key of the account issuing the transaction.
// A valid public key is 32 bytes long.
// * `params`: The *serialized parameters* of the module command.
// * `signatures`: An array with the signatures of the transaction.
// A transaction is signed by the sender account to verify its correctness.
// In case of a multi-signature transaction, several accounts need to sign a transaction, before it is accepted by a node.

// .How many transactions fit in a block?
// [NOTE]
// ====
// How many transactions can actually fit into a block?
// The answer to this question very much depends on the size of the particular transactions.
// As every transaction type expects a different set of params to be included in the transaction, the size of transactions can vary significantly between different transaction types.

// Let's make an example for simple token transfer transactions.
// If you assume all transactions are the simplest token transfers (Alice sends 5LSK to Bob etc.) then the size of each transaction is 153 Bytes.
// Each block can include a maximum of 15 kB of transactions.
// This results in maximum 100 token transfer transactions per block:

//  Total transactions size  = 15360 (15 x 1024)
//  transaction size = 153

//  15360/153 = 100.39 maximum token transfer transactions per block
// ====


// === Transaction JSON schema

// //TODO: Add link to https://github.com/LiskHQ/lips/pull/155/files when merged

// .Transaction schema
// [%collapsible]
// ====
// [source,js]
// ----
// transactionSchema = {
//     "type": "object",
//     "required": [
//         "moduleID",
//         "commandID",
//         "nonce",
//         "fee",
//         "senderPublicKey",
//         "params",
//         "signatures"
//     ],
//     "properties": {
//         "moduleID": {
//             "dataType": "bytes",
//             "length": 4,
//             "fieldNumber": 1
//         },
//         "commandID": {
//             "dataType": "bytes",
//             "length": 2,
//             "fieldNumber": 2
//         },
//         "nonce": {
//             "dataType": "uint64",
//             "fieldNumber": 3
//         },
//         "fee": {
//             "dataType": "uint64",
//             "fieldNumber": 4
//         },
//         "senderPublicKey": {
//             "dataType": "bytes",
//             "length": 32,
//             "fieldNumber": 5
//         },
//         "params": {
//             "dataType": "bytes",
//             "fieldNumber": 6
//         },
//         "signatures": {
//             "dataType": "array",
//             "items": {
//                 "dataType": "bytes",
//                 "length": 64
//             },
//             "fieldNumber": 7
//         }
//     }
// }
// ----
// ====

// === Valid vs invalid transactions

// Only valid transactions should be added to a block during the block generation, as an invalid transaction makes the whole block invalid, meaning that it would be discarded by any node in the network.

// A transaction is *valid*, if the following stages associated to the transaction of <<block-processing>> are executed successfully without errors:

// * "transaction verification"
// * "command verification"
// * "before command execution" and
// * "after command execution"

// Otherwise, a transaction is *invalid*.

// === Successful vs failed transactions
// A valid transaction is executed *successfully* if additionally the "command execution" stage of <<block-processing>> is executed successfully without errors.

// A valid transaction *fails* if on the other hand an error occurs during the command execution.
// In this case, all state transitions of the "command execution" stage are reverted.
// This means that the transaction has no effect except for those defined in "before command execution" and "after command execution".
// The result of the transaction execution is logged using an event emitted at the end of the "after transaction execution" stage, indicating whether the transaction was processed successfully or an error occurred.

// == Block generation

// The block generation flow offers a lot of flexibility for custom business logic of the blockchain application by providing hooks for executing additional custom logic before and after each execution of a transaction and/or command.
// The gradual steps make all important verification steps explicit and obvious.

// image::understand-blockchain/block-generation.png["Block generation steps",500, align="center"]

// The full generation of a block is organized as follows.

// . **Header initialization**: Block header properties that require access to the state store before any state transitions implied by the block are executed are inserted in this stage.
// +
// Sets the `version`, `timestamp`, `height`, `previousBlockID`, `generatorAddress`, `maxHeightPrevoted`, `maxHeightGenerated`, and `aggregateCommit` properties of the <<block-header>>.
// . **Assets insertion**: Each module can insert information in the block assets.
// . **Before transactions execution**: Each module can define protocol logic that is executed before the transactions contained in the block are processed.
// After this stage has been completed, transactions are selected one-by-one from a transaction pool.
// . **Transaction verification**: Each module can define protocol logic that verifies a transaction, possibly by accessing the state store.
// If an error occurs, the transaction is invalid and it is not included in the block.
// The transaction processing stages (steps 4 to 8) are repeated for each transaction selected.
// If step 4, 5, 6, and 8 are executed successfully, the transaction is valid and it is included in the block, otherwise it is invalid and therefore discarded.
// . **Command verification**: The command corresponding to the `moduleID`-`commandID` combination is verified.
// If an error occurs, the transaction is invalid and it is not included in the block.
// . **Before command execution**: Each module can define protocol logic that is processed before the command has been executed.
// If an error occurs, the transaction is invalid, it is not included in the block, all state transitions induced by the transaction are reverted.
// In that case, the block generation continues with step 4 for another transaction from the transaction pool or step 9.
// . **Command execution**: The command corresponding to the `moduleID`-`commandID` combination is executed.
// If an error occurs, the transaction is failed and all state transitions performed in this stage are reverted.
// In any case, afterwards the processing continues with the next stage.
// . **After command execution**: Each module can define protocol logic that is processed after the command has been executed.
// If an error occurs, the transaction is invalid, it is not included in the block and all state transitions induced by the transaction performed up to this stage are reverted.
// In that case, the block generation continues with step 4 for another transaction from the transaction pool or step 9.
// . **After transactions execution**: Each module can define protocol logic that is executed after all the transactions contained in the block have been processed.
// . **Header finalization**: Block header properties, which require accessing the state store after all state transitions implied by the block have been executed, are inserted.
// +
// Sets the `transactionRoot`, `assetRoot`, `eventRoot`, `stateRoot`, `validatorsHash`, and `signature` properties of the <<block-header>>.
// . **Block processing**: The block goes through the <<block-processing>> stages.

// == Block processing

// The block processing flow offers a lot of flexibility for custom business logic of the blockchain application by providing hooks for executing additional custom logic before and after each execution of a transaction and/or command.
// The gradual steps make all important verification steps explicit and obvious.

// image::understand-blockchain/block-processing.png["Block prosessing steps",500, align="center"]

// The full processing of a block is organized as follows.

// . **Block reception**: A new block is received from the P2P network.
// //TODO: Add link to definition of the fork choice rule
// . **Fork choice**: Upon receiving a new block, the fork choice rule determines whether the block will be discarded or if the processing continues.
// . **Static validation**: Some initial static checks are done to ensure that the serialized object follows the general structure of a block.
// These checks are performed immediately because they do not require access to the state store and can therefore be done very quickly.
// * Validates, if:
// ** the block follows the block schema.
// ** the total size of the serialized transactions contained in the block is at most the maximum allowed size for transactions per block.
// ** the block header is valid:
// *** checks that the block header follows the block header schema.
// *** validates the `version`, `transactionRoot`, and `assetRoot` properties.
// ** the block assets are valid:
// *** each entry in the assets array has `moduleID` set to the ID of a module registered in the chain
// *** the data property has size at most equal to the max size of an assets entry in bytes.
// *** each module can insert at most one entry in the block assets.
// *** the entries are sorted by increasing values of `moduleID`.
// . **Header verification**: Block header properties that require access to the state store before any state transitions implied by the block are executed are verified in this stage.
// +
// Verifies `timestamp`, `height`, `previousBlockID`, `generatorAddress`, `maxHeightPrevoted`, `maxHeightGenerated`, `aggregateCommit`, and `signature` properties of the <<block-header>>.
// . **Assets verification**: Each module verifies the respective entry in the block assets.
// If any check fails, the block is discarded and has no further effect.
// . **Block forwarding**: After the initial checks, the full block is forwarded to a subset of peers.
// . **Before transactions execution**: Each module can define protocol logic that is executed before the transactions contained in the block are processed.
// . **Transaction verification**: Each module can define protocol logic that verifies a transaction, possibly by accessing the state store.
// If an error occurs, the transaction is *invalid* and the whole block is discarded.
// . **Command verification**: The command corresponding to the `moduleID`-`commandID` combination is verified.
// If an error occurs, the transaction is *invalid* and the whole block is discarded.
// . **Before command execution**: Each module can define protocol logic that is processed before the command has been executed.
// If an error occurs, the transaction is *invalid* and the whole block is discarded.
// . **Command execution**: The command corresponding to the `moduleID`-`commandID` combination is executed.
// If an error occurs, the transaction is *failed* and all state transitions performed in this stage are reverted.
// In any case, afterwards the processing continues with the next stage.
// . **After command execution**: Each module can define protocol logic that is processed after the command has been executed.
// If an error occurs, the transaction is *invalid* and the whole block is discarded.
// . **After transactions execution**: Each module can define protocol logic that is executed after all the transactions contained in the block have been processed.
// . **Result verification**: Block header properties, which require accessing the state store after all state transitions implied by the block have been executed, are verified.
// +
// Verifies the `stateRoot`, `eventRoot`, and `validatorsHash` properties of the <<block-header>>.
// . **Block storage**: The block is persisted into the database.
// . **Peers notification**: Other peers in the P2P network are notified of the new block.




////
=== Default transaction types

The following transaction types are included in every blockchain application by default, if not configured otherwise:

[cols="1,2,1,1,1,6a"]
|===
|Module Name|Command Name|Module ID|Command ID|Size(min)|Description

|*Token*|*token transfer transaction*|2|0|153 Bytes|Transmit funds to another Lisk account.
|*Token*|*cross-chain token transfer transaction*|2|1||Transfers fungible tokens from one chain to another (e.g., mainchain to sidechain).

|*Auth*|*multisignature registration transaction*|12|0|219 Bytes|Registers a multi-signature account.

|*DPoS*|*delegate registration transaction*|13|0|308 Bytes|Registers a delegate for the sending account.
|*DPoS*|*delegate vote transaction*|13|1|147 Bytes|Submits or removes vote(s) for delegates.
|*DPoS*|*token unlock transaction*|13|2|117 Bytes|Unlocks locked tokens.
|*DPoS*|*delegate misbehavior report transaction*|13|3|991 Bytes|Reports a misbehavior of a delegate
|*DPoS*|*update generator key transaction*|13|4||

|*Interoperability*|*sidechain registration transaction*|64|0||Registers a sidechain/blockchain application.
|*Interoperability*|*mainchain registration transaction*|64|1||Registers the mainchain on a sidechain.
|*Interoperability*|*sidechain cross-chain update transaction*|64|2||Submits updates about the state of the sidechain and new cross-chain messages.
|*Interoperability*|*mainchain cross-chain update transaction*|64|3||Submits updates about the state of the mainchain and new cross-chain messages.
|*Interoperability*|*state recovery transaction*|64|4||description
|*Interoperability*|*message recovery transaction*|64|5||description
|*Interoperability*|*state recovery initialization transaction*|64|6||description
|===
////
